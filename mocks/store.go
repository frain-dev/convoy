// Code generated by MockGen. DO NOT EDIT.
// Source: datastore/db.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	datastore "github.com/frain-dev/convoy/datastore"
	gomock "github.com/golang/mock/gomock"
	bson "go.mongodb.org/mongo-driver/bson"
	mongo "go.mongodb.org/mongo-driver/mongo"
)

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *MockStore) Aggregate(ctx context.Context, pipeline mongo.Pipeline, result interface{}, allowDiskUse bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Aggregate", ctx, pipeline, result, allowDiskUse)
	ret0, _ := ret[0].(error)
	return ret0
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockStoreMockRecorder) Aggregate(ctx, pipeline, result, allowDiskUse interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockStore)(nil).Aggregate), ctx, pipeline, result, allowDiskUse)
}

// Count mocks base method.
func (m *MockStore) Count(ctx context.Context, filter map[string]interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Count", ctx, filter)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Count indicates an expected call of Count.
func (mr *MockStoreMockRecorder) Count(ctx, filter interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Count", reflect.TypeOf((*MockStore)(nil).Count), ctx, filter)
}

// CountWithDeleted mocks base method.
func (m *MockStore) CountWithDeleted(ctx context.Context, filter map[string]interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountWithDeleted", ctx, filter)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountWithDeleted indicates an expected call of CountWithDeleted.
func (mr *MockStoreMockRecorder) CountWithDeleted(ctx, filter interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountWithDeleted", reflect.TypeOf((*MockStore)(nil).CountWithDeleted), ctx, filter)
}

// DeleteByID mocks base method.
func (m *MockStore) DeleteByID(ctx context.Context, id string, hardDelete bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByID", ctx, id, hardDelete)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteByID indicates an expected call of DeleteByID.
func (mr *MockStoreMockRecorder) DeleteByID(ctx, id, hardDelete interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByID", reflect.TypeOf((*MockStore)(nil).DeleteByID), ctx, id, hardDelete)
}

// DeleteMany mocks base method.
func (m *MockStore) DeleteMany(ctx context.Context, filter, payload bson.M, hardDelete bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteMany", ctx, filter, payload, hardDelete)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteMany indicates an expected call of DeleteMany.
func (mr *MockStoreMockRecorder) DeleteMany(ctx, filter, payload, hardDelete interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteMany", reflect.TypeOf((*MockStore)(nil).DeleteMany), ctx, filter, payload, hardDelete)
}

// DeleteOne mocks base method.
func (m *MockStore) DeleteOne(ctx context.Context, filter bson.M, hardDelete bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteOne", ctx, filter, hardDelete)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteOne indicates an expected call of DeleteOne.
func (mr *MockStoreMockRecorder) DeleteOne(ctx, filter, hardDelete interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOne", reflect.TypeOf((*MockStore)(nil).DeleteOne), ctx, filter, hardDelete)
}

// FindAll mocks base method.
func (m *MockStore) FindAll(ctx context.Context, filter bson.M, sort, projection, results interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAll", ctx, filter, sort, projection, results)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindAll indicates an expected call of FindAll.
func (mr *MockStoreMockRecorder) FindAll(ctx, filter, sort, projection, results interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAll", reflect.TypeOf((*MockStore)(nil).FindAll), ctx, filter, sort, projection, results)
}

// FindByID mocks base method.
func (m *MockStore) FindByID(ctx context.Context, id string, projection bson.M, result interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", ctx, id, projection, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindByID indicates an expected call of FindByID.
func (mr *MockStoreMockRecorder) FindByID(ctx, id, projection, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockStore)(nil).FindByID), ctx, id, projection, result)
}

// FindMany mocks base method.
func (m *MockStore) FindMany(ctx context.Context, filter, projection bson.M, sort interface{}, page, limit int64, results interface{}) (datastore.PaginationData, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindMany", ctx, filter, projection, sort, page, limit, results)
	ret0, _ := ret[0].(datastore.PaginationData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindMany indicates an expected call of FindMany.
func (mr *MockStoreMockRecorder) FindMany(ctx, filter, projection, sort, page, limit, results interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMany", reflect.TypeOf((*MockStore)(nil).FindMany), ctx, filter, projection, sort, page, limit, results)
}

// FindManyWithDeletedAt mocks base method.
func (m *MockStore) FindManyWithDeletedAt(ctx context.Context, filter, projection bson.M, sort interface{}, limit, skip int64, results interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindManyWithDeletedAt", ctx, filter, projection, sort, limit, skip, results)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindManyWithDeletedAt indicates an expected call of FindManyWithDeletedAt.
func (mr *MockStoreMockRecorder) FindManyWithDeletedAt(ctx, filter, projection, sort, limit, skip, results interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindManyWithDeletedAt", reflect.TypeOf((*MockStore)(nil).FindManyWithDeletedAt), ctx, filter, projection, sort, limit, skip, results)
}

// FindOne mocks base method.
func (m *MockStore) FindOne(ctx context.Context, filter, projection bson.M, result interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindOne", ctx, filter, projection, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// FindOne indicates an expected call of FindOne.
func (mr *MockStoreMockRecorder) FindOne(ctx, filter, projection, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindOne", reflect.TypeOf((*MockStore)(nil).FindOne), ctx, filter, projection, result)
}

// Inc mocks base method.
func (m *MockStore) Inc(ctx context.Context, filter bson.M, payload interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Inc", ctx, filter, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// Inc indicates an expected call of Inc.
func (mr *MockStoreMockRecorder) Inc(ctx, filter, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Inc", reflect.TypeOf((*MockStore)(nil).Inc), ctx, filter, payload)
}

// Save mocks base method.
func (m *MockStore) Save(ctx context.Context, payload, result interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, payload, result)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockStoreMockRecorder) Save(ctx, payload, result interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockStore)(nil).Save), ctx, payload, result)
}

// SaveMany mocks base method.
func (m *MockStore) SaveMany(ctx context.Context, payload []interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveMany", ctx, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveMany indicates an expected call of SaveMany.
func (mr *MockStoreMockRecorder) SaveMany(ctx, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveMany", reflect.TypeOf((*MockStore)(nil).SaveMany), ctx, payload)
}

// UpdateByID mocks base method.
func (m *MockStore) UpdateByID(ctx context.Context, id string, payload interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateByID", ctx, id, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateByID indicates an expected call of UpdateByID.
func (mr *MockStoreMockRecorder) UpdateByID(ctx, id, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateByID", reflect.TypeOf((*MockStore)(nil).UpdateByID), ctx, id, payload)
}

// UpdateMany mocks base method.
func (m *MockStore) UpdateMany(ctx context.Context, filter, payload bson.M, bulk bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateMany", ctx, filter, payload, bulk)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateMany indicates an expected call of UpdateMany.
func (mr *MockStoreMockRecorder) UpdateMany(ctx, filter, payload, bulk interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateMany", reflect.TypeOf((*MockStore)(nil).UpdateMany), ctx, filter, payload, bulk)
}

// UpdateOne mocks base method.
func (m *MockStore) UpdateOne(ctx context.Context, filter bson.M, payload interface{}) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateOne", ctx, filter, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateOne indicates an expected call of UpdateOne.
func (mr *MockStoreMockRecorder) UpdateOne(ctx, filter, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateOne", reflect.TypeOf((*MockStore)(nil).UpdateOne), ctx, filter, payload)
}

// WithTransaction mocks base method.
func (m *MockStore) WithTransaction(ctx context.Context, fn func(mongo.SessionContext) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithTransaction", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// WithTransaction indicates an expected call of WithTransaction.
func (mr *MockStoreMockRecorder) WithTransaction(ctx, fn interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithTransaction", reflect.TypeOf((*MockStore)(nil).WithTransaction), ctx, fn)
}
