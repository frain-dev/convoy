// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one

SELECT COUNT(*) AS count FROM convoy.users WHERE deleted_at IS NULL
`

// ============================================================================
// COUNT Operations
// ============================================================================
func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :exec


INSERT INTO convoy.users (
    id, first_name, last_name, email, password,
    email_verified, reset_password_token, email_verification_token,
    reset_password_expires_at, email_verification_expires_at, auth_type,
    created_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7, $8,
    $9, $10, $11,
    CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
`

type CreateUserParams struct {
	ID                         string
	FirstName                  string
	LastName                   string
	Email                      string
	Password                   string
	EmailVerified              bool
	ResetPasswordToken         pgtype.Text
	EmailVerificationToken     pgtype.Text
	ResetPasswordExpiresAt     pgtype.Timestamptz
	EmailVerificationExpiresAt pgtype.Timestamptz
	AuthType                   string
}

// Users Queries
// ============================================================================
// CREATE Operations
// ============================================================================
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.EmailVerified,
		arg.ResetPasswordToken,
		arg.EmailVerificationToken,
		arg.ResetPasswordExpiresAt,
		arg.EmailVerificationExpiresAt,
		arg.AuthType,
	)
	return err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, first_name, last_name, email, password, email_verified, reset_password_token, email_verification_token, created_at, updated_at, deleted_at, reset_password_expires_at, email_verification_expires_at, auth_type FROM convoy.users WHERE email = $1 AND deleted_at IS NULL
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (ConvoyUser, error) {
	row := q.db.QueryRow(ctx, findUserByEmail, email)
	var i ConvoyUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.EmailVerified,
		&i.ResetPasswordToken,
		&i.EmailVerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ResetPasswordExpiresAt,
		&i.EmailVerificationExpiresAt,
		&i.AuthType,
	)
	return i, err
}

const findUserByEmailVerificationToken = `-- name: FindUserByEmailVerificationToken :one
SELECT id, first_name, last_name, email, password, email_verified, reset_password_token, email_verification_token, created_at, updated_at, deleted_at, reset_password_expires_at, email_verification_expires_at, auth_type FROM convoy.users WHERE email_verification_token = $1::text AND deleted_at IS NULL
`

func (q *Queries) FindUserByEmailVerificationToken(ctx context.Context, token string) (ConvoyUser, error) {
	row := q.db.QueryRow(ctx, findUserByEmailVerificationToken, token)
	var i ConvoyUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.EmailVerified,
		&i.ResetPasswordToken,
		&i.EmailVerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ResetPasswordExpiresAt,
		&i.EmailVerificationExpiresAt,
		&i.AuthType,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one

SELECT id, first_name, last_name, email, password, email_verified, reset_password_token, email_verification_token, created_at, updated_at, deleted_at, reset_password_expires_at, email_verification_expires_at, auth_type FROM convoy.users WHERE id = $1 AND deleted_at IS NULL
`

// ============================================================================
// FETCH Operations
// ============================================================================
func (q *Queries) FindUserByID(ctx context.Context, id string) (ConvoyUser, error) {
	row := q.db.QueryRow(ctx, findUserByID, id)
	var i ConvoyUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.EmailVerified,
		&i.ResetPasswordToken,
		&i.EmailVerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ResetPasswordExpiresAt,
		&i.EmailVerificationExpiresAt,
		&i.AuthType,
	)
	return i, err
}

const findUserByToken = `-- name: FindUserByToken :one
SELECT id, first_name, last_name, email, password, email_verified, reset_password_token, email_verification_token, created_at, updated_at, deleted_at, reset_password_expires_at, email_verification_expires_at, auth_type FROM convoy.users WHERE reset_password_token = $1::text AND deleted_at IS NULL
`

func (q *Queries) FindUserByToken(ctx context.Context, token string) (ConvoyUser, error) {
	row := q.db.QueryRow(ctx, findUserByToken, token)
	var i ConvoyUser
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Password,
		&i.EmailVerified,
		&i.ResetPasswordToken,
		&i.EmailVerificationToken,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ResetPasswordExpiresAt,
		&i.EmailVerificationExpiresAt,
		&i.AuthType,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :execresult

UPDATE convoy.users SET
    first_name = $1,
    last_name = $2,
    email = $3,
    password = $4,
    email_verified = $5,
    reset_password_token = $6,
    email_verification_token = $7,
    reset_password_expires_at = $8,
    email_verification_expires_at = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $10 AND deleted_at IS NULL
`

type UpdateUserParams struct {
	FirstName                  string
	LastName                   string
	Email                      string
	Password                   string
	EmailVerified              bool
	ResetPasswordToken         pgtype.Text
	EmailVerificationToken     pgtype.Text
	ResetPasswordExpiresAt     pgtype.Timestamptz
	EmailVerificationExpiresAt pgtype.Timestamptz
	ID                         string
}

// ============================================================================
// UPDATE Operations
// ============================================================================
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateUser,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Password,
		arg.EmailVerified,
		arg.ResetPasswordToken,
		arg.EmailVerificationToken,
		arg.ResetPasswordExpiresAt,
		arg.EmailVerificationExpiresAt,
		arg.ID,
	)
}
