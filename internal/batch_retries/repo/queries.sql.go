// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createBatchRetry = `-- name: CreateBatchRetry :exec

INSERT INTO convoy.batch_retries (
    id, project_id, status, total_events, processed_events, failed_events,
    filter, created_at, updated_at, completed_at, error
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11
)
`

type CreateBatchRetryParams struct {
	ID              string
	ProjectID       string
	Status          string
	TotalEvents     int32
	ProcessedEvents int32
	FailedEvents    int32
	Filter          []byte
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
	CompletedAt     pgtype.Timestamptz
	Error           pgtype.Text
}

// Batch Retry Repository SQLc Queries
// This file contains all SQL queries for batch retry operations
func (q *Queries) CreateBatchRetry(ctx context.Context, arg CreateBatchRetryParams) error {
	_, err := q.db.Exec(ctx, createBatchRetry,
		arg.ID,
		arg.ProjectID,
		arg.Status,
		arg.TotalEvents,
		arg.ProcessedEvents,
		arg.FailedEvents,
		arg.Filter,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.CompletedAt,
		arg.Error,
	)
	return err
}

const findActiveBatchRetry = `-- name: FindActiveBatchRetry :one
SELECT id, project_id, status, total_events, processed_events, failed_events, filter, created_at, updated_at, completed_at, error FROM convoy.batch_retries
WHERE project_id = $1
AND status IN ($2, $3)
ORDER BY created_at DESC
LIMIT 1
`

type FindActiveBatchRetryParams struct {
	ProjectID string
	Status1   string
	Status2   string
}

func (q *Queries) FindActiveBatchRetry(ctx context.Context, arg FindActiveBatchRetryParams) (ConvoyBatchRetry, error) {
	row := q.db.QueryRow(ctx, findActiveBatchRetry, arg.ProjectID, arg.Status1, arg.Status2)
	var i ConvoyBatchRetry
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.TotalEvents,
		&i.ProcessedEvents,
		&i.FailedEvents,
		&i.Filter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Error,
	)
	return i, err
}

const findBatchRetryByID = `-- name: FindBatchRetryByID :one
SELECT id, project_id, status, total_events, processed_events, failed_events, filter, created_at, updated_at, completed_at, error FROM convoy.batch_retries WHERE id = $1
`

func (q *Queries) FindBatchRetryByID(ctx context.Context, id string) (ConvoyBatchRetry, error) {
	row := q.db.QueryRow(ctx, findBatchRetryByID, id)
	var i ConvoyBatchRetry
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.TotalEvents,
		&i.ProcessedEvents,
		&i.FailedEvents,
		&i.Filter,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.Error,
	)
	return i, err
}

const updateBatchRetry = `-- name: UpdateBatchRetry :execresult
UPDATE convoy.batch_retries SET
    status = $1,
    processed_events = $2,
    failed_events = $3,
    updated_at = $4,
    filter = $5,
    total_events = $6,
    completed_at = $7,
    error = $8
WHERE id = $9 AND project_id = $10
`

type UpdateBatchRetryParams struct {
	Status          string
	ProcessedEvents int32
	FailedEvents    int32
	UpdatedAt       pgtype.Timestamptz
	Filter          []byte
	TotalEvents     int32
	CompletedAt     pgtype.Timestamptz
	Error           pgtype.Text
	ID              string
	ProjectID       string
}

func (q *Queries) UpdateBatchRetry(ctx context.Context, arg UpdateBatchRetryParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateBatchRetry,
		arg.Status,
		arg.ProcessedEvents,
		arg.FailedEvents,
		arg.UpdatedAt,
		arg.Filter,
		arg.TotalEvents,
		arg.CompletedAt,
		arg.Error,
		arg.ID,
		arg.ProjectID,
	)
}
