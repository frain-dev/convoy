// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createDeliveryAttempt = `-- name: CreateDeliveryAttempt :exec

INSERT INTO convoy.delivery_attempts (
    id, url, method, api_version, endpoint_id, event_delivery_id, project_id,
    ip_address, request_http_header, response_http_header, http_status, response_data, error, status
)
VALUES ($1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10, $11, $12, $13, $14)
`

type CreateDeliveryAttemptParams struct {
	ID                 string
	Url                string
	Method             string
	ApiVersion         string
	EndpointID         string
	EventDeliveryID    string
	ProjectID          string
	IpAddress          pgtype.Text
	RequestHttpHeader  []byte
	ResponseHttpHeader []byte
	HttpStatus         pgtype.Text
	ResponseData       []byte
	Error              pgtype.Text
	Status             pgtype.Bool
}

// Delivery Attempts Queries
func (q *Queries) CreateDeliveryAttempt(ctx context.Context, arg CreateDeliveryAttemptParams) error {
	_, err := q.db.Exec(ctx, createDeliveryAttempt,
		arg.ID,
		arg.Url,
		arg.Method,
		arg.ApiVersion,
		arg.EndpointID,
		arg.EventDeliveryID,
		arg.ProjectID,
		arg.IpAddress,
		arg.RequestHttpHeader,
		arg.ResponseHttpHeader,
		arg.HttpStatus,
		arg.ResponseData,
		arg.Error,
		arg.Status,
	)
	return err
}

const findDeliveryAttemptById = `-- name: FindDeliveryAttemptById :one
SELECT
    id,
    url,
    method,
    api_version,
    endpoint_id,
    event_delivery_id,
    project_id,
    ip_address,
    request_http_header,
    response_http_header,
    http_status,
    response_data,
    error,
    status,
    created_at,
    updated_at,
    deleted_at
FROM convoy.delivery_attempts
WHERE id = $1 AND event_delivery_id = $2 AND deleted_at IS NULL
`

type FindDeliveryAttemptByIdParams struct {
	ID              string
	EventDeliveryID string
}

type FindDeliveryAttemptByIdRow struct {
	ID                 string
	Url                string
	Method             string
	ApiVersion         string
	EndpointID         string
	EventDeliveryID    string
	ProjectID          string
	IpAddress          pgtype.Text
	RequestHttpHeader  []byte
	ResponseHttpHeader []byte
	HttpStatus         pgtype.Text
	ResponseData       []byte
	Error              pgtype.Text
	Status             pgtype.Bool
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
	DeletedAt          pgtype.Timestamptz
}

func (q *Queries) FindDeliveryAttemptById(ctx context.Context, arg FindDeliveryAttemptByIdParams) (FindDeliveryAttemptByIdRow, error) {
	row := q.db.QueryRow(ctx, findDeliveryAttemptById, arg.ID, arg.EventDeliveryID)
	var i FindDeliveryAttemptByIdRow
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Method,
		&i.ApiVersion,
		&i.EndpointID,
		&i.EventDeliveryID,
		&i.ProjectID,
		&i.IpAddress,
		&i.RequestHttpHeader,
		&i.ResponseHttpHeader,
		&i.HttpStatus,
		&i.ResponseData,
		&i.Error,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const findDeliveryAttempts = `-- name: FindDeliveryAttempts :many
WITH att AS (
    SELECT
        id,
        url,
        method,
        api_version,
        endpoint_id,
        event_delivery_id,
        project_id,
        ip_address,
        request_http_header,
        response_http_header,
        http_status,
        response_data,
        error,
        status,
        created_at,
        updated_at,
        deleted_at
    FROM convoy.delivery_attempts
    WHERE event_delivery_id = $1 AND deleted_at IS NULL
    ORDER BY created_at DESC
    LIMIT 10
)
SELECT id, url, method, api_version, endpoint_id, event_delivery_id, project_id, ip_address, request_http_header, response_http_header, http_status, response_data, error, status, created_at, updated_at, deleted_at FROM att ORDER BY created_at ASC
`

type FindDeliveryAttemptsRow struct {
	ID                 string
	Url                string
	Method             string
	ApiVersion         string
	EndpointID         string
	EventDeliveryID    string
	ProjectID          string
	IpAddress          pgtype.Text
	RequestHttpHeader  []byte
	ResponseHttpHeader []byte
	HttpStatus         pgtype.Text
	ResponseData       []byte
	Error              pgtype.Text
	Status             pgtype.Bool
	CreatedAt          pgtype.Timestamptz
	UpdatedAt          pgtype.Timestamptz
	DeletedAt          pgtype.Timestamptz
}

// Fetch last 10 delivery attempts for an event delivery, ordered by created_at
func (q *Queries) FindDeliveryAttempts(ctx context.Context, eventDeliveryID string) ([]FindDeliveryAttemptsRow, error) {
	rows, err := q.db.Query(ctx, findDeliveryAttempts, eventDeliveryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindDeliveryAttemptsRow
	for rows.Next() {
		var i FindDeliveryAttemptsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Method,
			&i.ApiVersion,
			&i.EndpointID,
			&i.EventDeliveryID,
			&i.ProjectID,
			&i.IpAddress,
			&i.RequestHttpHeader,
			&i.ResponseHttpHeader,
			&i.HttpStatus,
			&i.ResponseData,
			&i.Error,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailureAndSuccessCounts = `-- name: GetFailureAndSuccessCounts :many
SELECT
    endpoint_id AS key,
    project_id AS tenant_id,
    COUNT(CASE WHEN status = false THEN 1 END)::bigint AS failures,
    COUNT(CASE WHEN status = true THEN 1 END)::bigint AS successes
FROM convoy.delivery_attempts
WHERE deleted_at IS NULL
    AND created_at >= NOW() - MAKE_INTERVAL(mins := $1)
GROUP BY endpoint_id, project_id
`

type GetFailureAndSuccessCountsRow struct {
	Key       string
	TenantID  string
	Failures  int64
	Successes int64
}

// Get failure and success counts for endpoints within the lookback duration
// This replaces the n+1 query pattern in the legacy implementation
func (q *Queries) GetFailureAndSuccessCounts(ctx context.Context, lookBackDuration int32) ([]GetFailureAndSuccessCountsRow, error) {
	rows, err := q.db.Query(ctx, getFailureAndSuccessCounts, lookBackDuration)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailureAndSuccessCountsRow
	for rows.Next() {
		var i GetFailureAndSuccessCountsRow
		if err := rows.Scan(
			&i.Key,
			&i.TenantID,
			&i.Failures,
			&i.Successes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailureAndSuccessCountsWithResetTime = `-- name: GetFailureAndSuccessCountsWithResetTime :one
SELECT
    endpoint_id AS key,
    project_id AS tenant_id,
    COUNT(CASE WHEN status = false THEN 1 END)::bigint AS failures,
    COUNT(CASE WHEN status = true THEN 1 END)::bigint AS successes
FROM convoy.delivery_attempts
WHERE endpoint_id = $1
    AND deleted_at IS NULL
    AND created_at >= $2
GROUP BY endpoint_id, project_id
`

type GetFailureAndSuccessCountsWithResetTimeParams struct {
	EndpointID string
	ResetTime  pgtype.Timestamptz
}

type GetFailureAndSuccessCountsWithResetTimeRow struct {
	Key       string
	TenantID  string
	Failures  int64
	Successes int64
}

// Get counts for a specific endpoint from a specific reset time
// This is used when circuit breaker has been reset for specific endpoints
func (q *Queries) GetFailureAndSuccessCountsWithResetTime(ctx context.Context, arg GetFailureAndSuccessCountsWithResetTimeParams) (GetFailureAndSuccessCountsWithResetTimeRow, error) {
	row := q.db.QueryRow(ctx, getFailureAndSuccessCountsWithResetTime, arg.EndpointID, arg.ResetTime)
	var i GetFailureAndSuccessCountsWithResetTimeRow
	err := row.Scan(
		&i.Key,
		&i.TenantID,
		&i.Failures,
		&i.Successes,
	)
	return i, err
}

const hardDeleteProjectDeliveryAttempts = `-- name: HardDeleteProjectDeliveryAttempts :execresult
DELETE FROM convoy.delivery_attempts
WHERE project_id = $1
    AND created_at >= $2
    AND created_at <= $3
`

type HardDeleteProjectDeliveryAttemptsParams struct {
	ProjectID      string
	CreatedAtStart pgtype.Timestamptz
	CreatedAtEnd   pgtype.Timestamptz
}

func (q *Queries) HardDeleteProjectDeliveryAttempts(ctx context.Context, arg HardDeleteProjectDeliveryAttemptsParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, hardDeleteProjectDeliveryAttempts, arg.ProjectID, arg.CreatedAtStart, arg.CreatedAtEnd)
}

const softDeleteProjectDeliveryAttempts = `-- name: SoftDeleteProjectDeliveryAttempts :execresult
UPDATE convoy.delivery_attempts
SET deleted_at = NOW()
WHERE project_id = $1
    AND created_at >= $2
    AND created_at <= $3
    AND deleted_at IS NULL
`

type SoftDeleteProjectDeliveryAttemptsParams struct {
	ProjectID      string
	CreatedAtStart pgtype.Timestamptz
	CreatedAtEnd   pgtype.Timestamptz
}

func (q *Queries) SoftDeleteProjectDeliveryAttempts(ctx context.Context, arg SoftDeleteProjectDeliveryAttemptsParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, softDeleteProjectDeliveryAttempts, arg.ProjectID, arg.CreatedAtStart, arg.CreatedAtEnd)
}
