// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPrevMetaEvents = `-- name: CountPrevMetaEvents :one
SELECT COALESCE(COUNT(DISTINCT id), 0) AS count
FROM convoy.meta_events
WHERE deleted_at IS NULL
    AND project_id = $1
    AND created_at >= $2
    AND created_at <= $3
    AND id > $4
`

type CountPrevMetaEventsParams struct {
	ProjectID string
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Cursor    string
}

// Count records before the given cursor (for pagination metadata)
// Uses same filters as FetchMetaEventsPaginated
//
// This query counts how many records exist with ID > cursor
// which tells us how many records are on previous pages
func (q *Queries) CountPrevMetaEvents(ctx context.Context, arg CountPrevMetaEventsParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, countPrevMetaEvents,
		arg.ProjectID,
		arg.StartDate,
		arg.EndDate,
		arg.Cursor,
	)
	var count pgtype.Int8
	err := row.Scan(&count)
	return count, err
}

const createMetaEvent = `-- name: CreateMetaEvent :exec


INSERT INTO convoy.meta_events (
    id, event_type, project_id, metadata, status
) VALUES (
    $1, $2, $3, $4, $5
)
`

type CreateMetaEventParams struct {
	ID        string
	EventType string
	ProjectID string
	Metadata  []byte
	Status    string
}

// Meta Events Queries
// Schema: convoy.meta_events
// Columns: id, project_id, event_type, metadata, attempt, status, created_at, updated_at, deleted_at
// ============================================================================
// CREATE Operations
// ============================================================================
func (q *Queries) CreateMetaEvent(ctx context.Context, arg CreateMetaEventParams) error {
	_, err := q.db.Exec(ctx, createMetaEvent,
		arg.ID,
		arg.EventType,
		arg.ProjectID,
		arg.Metadata,
		arg.Status,
	)
	return err
}

const fetchMetaEventsPaginated = `-- name: FetchMetaEventsPaginated :many

WITH filtered_meta_events AS (
    SELECT
        id,
        project_id,
        event_type,
        metadata,
        attempt,
        status,
        created_at,
        updated_at
    FROM convoy.meta_events
    WHERE deleted_at IS NULL
        AND project_id = $2
        AND created_at >= $3
        AND created_at <= $4
        -- Cursor-based pagination: <= for forward (next), >= for backward (prev)
        -- Skip cursor check if cursor is empty (first page)
        AND (
            CASE
                WHEN $5 = '' THEN true
                WHEN $1::text = 'next' THEN id <= $5
                WHEN $1::text = 'prev' THEN id >= $5
                ELSE true
            END
        )
    ORDER BY
        CASE WHEN $1::text = 'next' THEN id END DESC,
        CASE WHEN $1::text = 'prev' THEN id END ASC
    LIMIT $6
)
SELECT id, project_id, event_type, metadata, attempt, status, created_at, updated_at FROM filtered_meta_events
ORDER BY
    CASE WHEN $1::text = 'prev' THEN id END DESC,
    CASE WHEN $1::text = 'next' THEN id END DESC
`

type FetchMetaEventsPaginatedParams struct {
	Direction string
	ProjectID string
	StartDate pgtype.Timestamptz
	EndDate   pgtype.Timestamptz
	Cursor    pgtype.Text
	LimitVal  int64
}

type FetchMetaEventsPaginatedRow struct {
	ID        string
	ProjectID string
	EventType string
	Metadata  []byte
	Attempt   []byte
	Status    string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

// ============================================================================
// PAGINATED READ Operations
// ============================================================================
// Unified pagination query that handles:
// - Bidirectional pagination (forward with 'next', backward with 'prev')
// - Date range filtering
// - Soft delete filtering (deleted_at IS NULL)
//
// Parameters:
// @direction: 'next' for forward pagination, 'prev' for backward pagination
// @cursor: ID of the last item from previous page (empty string for first page)
// @project_id: Filter by project_id
// @start_date: Start of date range filter
// @end_date: End of date range filter
// @limit_val: Number of records to fetch (should be PerPage + 1 for hasNext detection)
// Final select: reverse order for backward pagination to maintain DESC ordering
func (q *Queries) FetchMetaEventsPaginated(ctx context.Context, arg FetchMetaEventsPaginatedParams) ([]FetchMetaEventsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchMetaEventsPaginated,
		arg.Direction,
		arg.ProjectID,
		arg.StartDate,
		arg.EndDate,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchMetaEventsPaginatedRow
	for rows.Next() {
		var i FetchMetaEventsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.EventType,
			&i.Metadata,
			&i.Attempt,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findMetaEventByID = `-- name: FindMetaEventByID :one

SELECT
    id,
    project_id,
    event_type,
    metadata,
    attempt,
    status,
    created_at,
    updated_at
FROM convoy.meta_events
WHERE id = $1 AND project_id = $2 AND deleted_at IS NULL
`

type FindMetaEventByIDParams struct {
	ID        string
	ProjectID string
}

type FindMetaEventByIDRow struct {
	ID        string
	ProjectID string
	EventType string
	Metadata  []byte
	Attempt   []byte
	Status    string
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

// ============================================================================
// READ Operations - Single Record
// ============================================================================
func (q *Queries) FindMetaEventByID(ctx context.Context, arg FindMetaEventByIDParams) (FindMetaEventByIDRow, error) {
	row := q.db.QueryRow(ctx, findMetaEventByID, arg.ID, arg.ProjectID)
	var i FindMetaEventByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.EventType,
		&i.Metadata,
		&i.Attempt,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMetaEvent = `-- name: UpdateMetaEvent :execresult

UPDATE convoy.meta_events
SET
    event_type = $1,
    metadata = $2,
    attempt = $3,
    status = $4,
    updated_at = NOW()
WHERE id = $5 AND project_id = $6 AND deleted_at IS NULL
`

type UpdateMetaEventParams struct {
	EventType string
	Metadata  []byte
	Attempt   []byte
	Status    string
	ID        string
	ProjectID string
}

// ============================================================================
// UPDATE Operations
// ============================================================================
func (q *Queries) UpdateMetaEvent(ctx context.Context, arg UpdateMetaEventParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateMetaEvent,
		arg.EventType,
		arg.Metadata,
		arg.Attempt,
		arg.Status,
		arg.ID,
		arg.ProjectID,
	)
}
