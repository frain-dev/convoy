// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countInstanceAdminUsers = `-- name: CountInstanceAdminUsers :one
SELECT COUNT(*)
FROM convoy.organisation_members o
WHERE o.role_type = 'instance_admin'
    AND o.deleted_at IS NULL
`

func (q *Queries) CountInstanceAdminUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countInstanceAdminUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrganisationAdminUsers = `-- name: CountOrganisationAdminUsers :one
SELECT COUNT(*)
FROM convoy.organisation_members o
WHERE o.role_type = 'organisation_admin'
    AND o.deleted_at IS NULL
`

func (q *Queries) CountOrganisationAdminUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrganisationAdminUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrevOrganisationMembers = `-- name: CountPrevOrganisationMembers :one
SELECT COUNT(DISTINCT o.id) AS count
FROM convoy.organisation_members o
WHERE o.organisation_id = $1
    AND o.deleted_at IS NULL
    AND o.id > $2
`

type CountPrevOrganisationMembersParams struct {
	OrganisationID string
	Cursor         string
}

func (q *Queries) CountPrevOrganisationMembers(ctx context.Context, arg CountPrevOrganisationMembersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPrevOrganisationMembers, arg.OrganisationID, arg.Cursor)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrevUserOrganisations = `-- name: CountPrevUserOrganisations :one
SELECT COUNT(DISTINCT o.id) AS count
FROM convoy.organisation_members m
JOIN convoy.organisations o ON m.organisation_id = o.id
WHERE m.user_id = $1
    AND o.deleted_at IS NULL
    AND m.deleted_at IS NULL
    AND o.id > $2
`

type CountPrevUserOrganisationsParams struct {
	UserID string
	Cursor string
}

func (q *Queries) CountPrevUserOrganisations(ctx context.Context, arg CountPrevUserOrganisationsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPrevUserOrganisations, arg.UserID, arg.Cursor)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrganisationMember = `-- name: CreateOrganisationMember :exec


INSERT INTO convoy.organisation_members (
    id,
    organisation_id,
    user_id,
    role_type,
    role_project,
    role_endpoint
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type CreateOrganisationMemberParams struct {
	ID             string
	OrganisationID string
	UserID         string
	RoleType       string
	RoleProject    pgtype.Text
	RoleEndpoint   pgtype.Text
}

// Organisation Members SQLc Queries
// Migration from database/postgres/organisation_member.go to SQLc
// ===========================================================================
// Core CRUD Operations
// ===========================================================================
func (q *Queries) CreateOrganisationMember(ctx context.Context, arg CreateOrganisationMemberParams) error {
	_, err := q.db.Exec(ctx, createOrganisationMember,
		arg.ID,
		arg.OrganisationID,
		arg.UserID,
		arg.RoleType,
		arg.RoleProject,
		arg.RoleEndpoint,
	)
	return err
}

const deleteOrganisationMember = `-- name: DeleteOrganisationMember :exec
UPDATE convoy.organisation_members
SET deleted_at = NOW()
WHERE id = $1 AND organisation_id = $2 AND deleted_at IS NULL
`

type DeleteOrganisationMemberParams struct {
	ID             string
	OrganisationID string
}

func (q *Queries) DeleteOrganisationMember(ctx context.Context, arg DeleteOrganisationMemberParams) error {
	_, err := q.db.Exec(ctx, deleteOrganisationMember, arg.ID, arg.OrganisationID)
	return err
}

const fetchAnyOrganisationAdminByUserID = `-- name: FetchAnyOrganisationAdminByUserID :one
SELECT
    o.id,
    o.organisation_id,
    o.user_id,
    o.role_type,
    COALESCE(o.role_project, '') AS role_project,
    COALESCE(o.role_endpoint, '') AS role_endpoint,
    u.id AS user_metadata_user_id,
    u.first_name AS user_metadata_first_name,
    u.last_name AS user_metadata_last_name,
    u.email AS user_metadata_email,
    o.created_at,
    o.updated_at
FROM convoy.organisation_members o
LEFT JOIN convoy.users u ON o.user_id = u.id
WHERE o.user_id = $1
    AND o.role_type = 'organisation_admin'
    AND o.deleted_at IS NULL
LIMIT 1
`

type FetchAnyOrganisationAdminByUserIDRow struct {
	ID                    string
	OrganisationID        string
	UserID                string
	RoleType              string
	RoleProject           string
	RoleEndpoint          string
	UserMetadataUserID    pgtype.Text
	UserMetadataFirstName pgtype.Text
	UserMetadataLastName  pgtype.Text
	UserMetadataEmail     pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
}

func (q *Queries) FetchAnyOrganisationAdminByUserID(ctx context.Context, userID string) (FetchAnyOrganisationAdminByUserIDRow, error) {
	row := q.db.QueryRow(ctx, fetchAnyOrganisationAdminByUserID, userID)
	var i FetchAnyOrganisationAdminByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.UserID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.UserMetadataUserID,
		&i.UserMetadataFirstName,
		&i.UserMetadataLastName,
		&i.UserMetadataEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchInstanceAdminByUserID = `-- name: FetchInstanceAdminByUserID :one

SELECT
    o.id,
    o.organisation_id,
    o.user_id,
    o.role_type,
    COALESCE(o.role_project, '') AS role_project,
    COALESCE(o.role_endpoint, '') AS role_endpoint,
    u.id AS user_metadata_user_id,
    u.first_name AS user_metadata_first_name,
    u.last_name AS user_metadata_last_name,
    u.email AS user_metadata_email,
    o.created_at,
    o.updated_at
FROM convoy.organisation_members o
LEFT JOIN convoy.users u ON o.user_id = u.id
WHERE o.user_id = $1
    AND o.role_type = 'instance_admin'
    AND o.deleted_at IS NULL
LIMIT 1
`

type FetchInstanceAdminByUserIDRow struct {
	ID                    string
	OrganisationID        string
	UserID                string
	RoleType              string
	RoleProject           string
	RoleEndpoint          string
	UserMetadataUserID    pgtype.Text
	UserMetadataFirstName pgtype.Text
	UserMetadataLastName  pgtype.Text
	UserMetadataEmail     pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
}

// ===========================================================================
// Admin-Specific Queries
// ===========================================================================
func (q *Queries) FetchInstanceAdminByUserID(ctx context.Context, userID string) (FetchInstanceAdminByUserIDRow, error) {
	row := q.db.QueryRow(ctx, fetchInstanceAdminByUserID, userID)
	var i FetchInstanceAdminByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.UserID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.UserMetadataUserID,
		&i.UserMetadataFirstName,
		&i.UserMetadataLastName,
		&i.UserMetadataEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchOrganisationMemberByID = `-- name: FetchOrganisationMemberByID :one

SELECT
    o.id,
    o.organisation_id,
    o.user_id,
    o.role_type,
    COALESCE(o.role_project, '') AS role_project,
    COALESCE(o.role_endpoint, '') AS role_endpoint,
    u.id AS user_metadata_user_id,
    u.first_name AS user_metadata_first_name,
    u.last_name AS user_metadata_last_name,
    u.email AS user_metadata_email,
    o.created_at,
    o.updated_at
FROM convoy.organisation_members o
LEFT JOIN convoy.users u ON o.user_id = u.id
WHERE o.id = $1 AND o.organisation_id = $2 AND o.deleted_at IS NULL
`

type FetchOrganisationMemberByIDParams struct {
	ID             string
	OrganisationID string
}

type FetchOrganisationMemberByIDRow struct {
	ID                    string
	OrganisationID        string
	UserID                string
	RoleType              string
	RoleProject           string
	RoleEndpoint          string
	UserMetadataUserID    pgtype.Text
	UserMetadataFirstName pgtype.Text
	UserMetadataLastName  pgtype.Text
	UserMetadataEmail     pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
}

// ===========================================================================
// Fetch Single Member Queries (with User Metadata)
// ===========================================================================
func (q *Queries) FetchOrganisationMemberByID(ctx context.Context, arg FetchOrganisationMemberByIDParams) (FetchOrganisationMemberByIDRow, error) {
	row := q.db.QueryRow(ctx, fetchOrganisationMemberByID, arg.ID, arg.OrganisationID)
	var i FetchOrganisationMemberByIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.UserID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.UserMetadataUserID,
		&i.UserMetadataFirstName,
		&i.UserMetadataLastName,
		&i.UserMetadataEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchOrganisationMemberByUserID = `-- name: FetchOrganisationMemberByUserID :one
SELECT
    o.id,
    o.organisation_id,
    o.user_id,
    o.role_type,
    COALESCE(o.role_project, '') AS role_project,
    COALESCE(o.role_endpoint, '') AS role_endpoint,
    u.id AS user_metadata_user_id,
    u.first_name AS user_metadata_first_name,
    u.last_name AS user_metadata_last_name,
    u.email AS user_metadata_email,
    o.created_at,
    o.updated_at
FROM convoy.organisation_members o
LEFT JOIN convoy.users u ON o.user_id = u.id
WHERE o.user_id = $1 AND o.organisation_id = $2 AND o.deleted_at IS NULL
`

type FetchOrganisationMemberByUserIDParams struct {
	UserID         string
	OrganisationID string
}

type FetchOrganisationMemberByUserIDRow struct {
	ID                    string
	OrganisationID        string
	UserID                string
	RoleType              string
	RoleProject           string
	RoleEndpoint          string
	UserMetadataUserID    pgtype.Text
	UserMetadataFirstName pgtype.Text
	UserMetadataLastName  pgtype.Text
	UserMetadataEmail     pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
}

func (q *Queries) FetchOrganisationMemberByUserID(ctx context.Context, arg FetchOrganisationMemberByUserIDParams) (FetchOrganisationMemberByUserIDRow, error) {
	row := q.db.QueryRow(ctx, fetchOrganisationMemberByUserID, arg.UserID, arg.OrganisationID)
	var i FetchOrganisationMemberByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.UserID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.UserMetadataUserID,
		&i.UserMetadataFirstName,
		&i.UserMetadataLastName,
		&i.UserMetadataEmail,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchOrganisationMembersPaginated = `-- name: FetchOrganisationMembersPaginated :many

WITH filtered_members AS (
    SELECT
        o.id,
        o.organisation_id,
        o.user_id,
        o.role_type,
        COALESCE(o.role_project, '') AS role_project,
        COALESCE(o.role_endpoint, '') AS role_endpoint,
        u.id AS user_metadata_user_id,
        u.first_name AS user_metadata_first_name,
        u.last_name AS user_metadata_last_name,
        u.email AS user_metadata_email,
        o.created_at,
        o.updated_at
    FROM convoy.organisation_members o
    LEFT JOIN convoy.users u ON o.user_id = u.id
    WHERE o.organisation_id = $2
        AND o.deleted_at IS NULL
        AND (o.user_id = $3 OR $3 = '')
        AND (
            CASE
                WHEN $1::text = 'next' THEN o.id <= $4
                WHEN $1::text = 'prev' THEN o.id >= $4
                ELSE true
            END
        )
    ORDER BY
        CASE WHEN $1::text = 'next' THEN o.id END DESC,
        CASE WHEN $1::text = 'prev' THEN o.id END ASC
    LIMIT $5
)
SELECT id, organisation_id, user_id, role_type, role_project, role_endpoint, user_metadata_user_id, user_metadata_first_name, user_metadata_last_name, user_metadata_email, created_at, updated_at FROM filtered_members
ORDER BY
    CASE WHEN $1::text = 'prev' THEN id END DESC,
    CASE WHEN $1::text = 'next' THEN id END DESC
`

type FetchOrganisationMembersPaginatedParams struct {
	Direction      string
	OrganisationID string
	UserID         string
	Cursor         string
	LimitVal       int64
}

type FetchOrganisationMembersPaginatedRow struct {
	ID                    string
	OrganisationID        string
	UserID                string
	RoleType              string
	RoleProject           string
	RoleEndpoint          string
	UserMetadataUserID    pgtype.Text
	UserMetadataFirstName pgtype.Text
	UserMetadataLastName  pgtype.Text
	UserMetadataEmail     pgtype.Text
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
}

// ===========================================================================
// Pagination Queries - Organisation Members
// ===========================================================================
func (q *Queries) FetchOrganisationMembersPaginated(ctx context.Context, arg FetchOrganisationMembersPaginatedParams) ([]FetchOrganisationMembersPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchOrganisationMembersPaginated,
		arg.Direction,
		arg.OrganisationID,
		arg.UserID,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchOrganisationMembersPaginatedRow
	for rows.Next() {
		var i FetchOrganisationMembersPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.UserID,
			&i.RoleType,
			&i.RoleProject,
			&i.RoleEndpoint,
			&i.UserMetadataUserID,
			&i.UserMetadataFirstName,
			&i.UserMetadataLastName,
			&i.UserMetadataEmail,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserOrganisationsPaginated = `-- name: FetchUserOrganisationsPaginated :many

WITH user_organisations AS (
    SELECT
        o.id,
        o.name,
        o.owner_id,
        o.custom_domain,
        o.assigned_domain,
        o.created_at,
        o.updated_at,
        o.deleted_at
    FROM convoy.organisation_members m
    JOIN convoy.organisations o ON m.organisation_id = o.id
    WHERE m.user_id = $2
        AND o.deleted_at IS NULL
        AND m.deleted_at IS NULL
        AND (
            CASE
                WHEN $1::text = 'next' THEN o.id <= $3
                WHEN $1::text = 'prev' THEN o.id >= $3
                ELSE true
            END
        )
    ORDER BY
        CASE WHEN $1::text = 'next' THEN o.id END DESC,
        CASE WHEN $1::text = 'prev' THEN o.id END ASC
    LIMIT $4
)
SELECT id, name, owner_id, custom_domain, assigned_domain, created_at, updated_at, deleted_at FROM user_organisations
ORDER BY
    CASE WHEN $1::text = 'prev' THEN id END DESC,
    CASE WHEN $1::text = 'next' THEN id END DESC
`

type FetchUserOrganisationsPaginatedParams struct {
	Direction string
	UserID    string
	Cursor    string
	LimitVal  int64
}

type FetchUserOrganisationsPaginatedRow struct {
	ID             string
	Name           string
	OwnerID        string
	CustomDomain   pgtype.Text
	AssignedDomain pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
}

// ===========================================================================
// Pagination Queries - User Organisations
// ===========================================================================
func (q *Queries) FetchUserOrganisationsPaginated(ctx context.Context, arg FetchUserOrganisationsPaginatedParams) ([]FetchUserOrganisationsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchUserOrganisationsPaginated,
		arg.Direction,
		arg.UserID,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchUserOrganisationsPaginatedRow
	for rows.Next() {
		var i FetchUserOrganisationsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.OwnerID,
			&i.CustomDomain,
			&i.AssignedDomain,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserProjects = `-- name: FindUserProjects :many

SELECT
    p.id,
    p.name,
    p.type,
    p.retained_events,
    p.logo_url,
    p.organisation_id,
    p.project_configuration_id,
    p.created_at,
    p.updated_at
FROM convoy.organisation_members m
RIGHT JOIN convoy.projects p ON p.organisation_id = m.organisation_id
WHERE m.user_id = $1
    AND m.deleted_at IS NULL
    AND p.deleted_at IS NULL
`

type FindUserProjectsRow struct {
	ID                     string
	Name                   string
	Type                   string
	RetainedEvents         pgtype.Int4
	LogoUrl                pgtype.Text
	OrganisationID         string
	ProjectConfigurationID string
	CreatedAt              pgtype.Timestamptz
	UpdatedAt              pgtype.Timestamptz
}

// ===========================================================================
// Project Queries
// ===========================================================================
func (q *Queries) FindUserProjects(ctx context.Context, userID string) ([]FindUserProjectsRow, error) {
	rows, err := q.db.Query(ctx, findUserProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserProjectsRow
	for rows.Next() {
		var i FindUserProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.RetainedEvents,
			&i.LogoUrl,
			&i.OrganisationID,
			&i.ProjectConfigurationID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasInstanceAdminAccess = `-- name: HasInstanceAdminAccess :one
SELECT EXISTS (
    SELECT 1 FROM convoy.organisation_members o
    WHERE o.user_id = $1
        AND o.role_type = 'instance_admin'
        AND o.deleted_at IS NULL
) OR NOT EXISTS (
    SELECT 1 FROM convoy.organisation_members o
    WHERE o.role_type = 'instance_admin'
        AND o.deleted_at IS NULL
        AND o.user_id != $1
)
`

func (q *Queries) HasInstanceAdminAccess(ctx context.Context, userID string) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, hasInstanceAdminAccess, userID)
	var column_1 pgtype.Bool
	err := row.Scan(&column_1)
	return column_1, err
}

const isFirstInstanceAdmin = `-- name: IsFirstInstanceAdmin :one
SELECT EXISTS (
    SELECT 1 FROM convoy.organisation_members o1
    WHERE o1.user_id = $1
        AND o1.deleted_at IS NULL
        AND (
            -- Case 1: User is first local instance admin
            (o1.role_type = 'instance_admin'
             AND EXISTS (
                 SELECT 1 FROM convoy.users u
                 WHERE u.id = o1.user_id
                     AND (u.auth_type = 'local' OR u.auth_type IS NULL OR u.auth_type = '')
             )
             AND o1.created_at = (
                 SELECT MIN(o2.created_at)
                 FROM convoy.organisation_members o2
                 JOIN convoy.users u2 ON o2.user_id = u2.id
                 WHERE o2.role_type = 'instance_admin'
                     AND o2.deleted_at IS NULL
                     AND (u2.auth_type = 'local' OR u2.auth_type IS NULL OR u2.auth_type = '')
             ))
            OR
            -- Case 2: User is first local organisation_admin when no local instance admins exist
            (o1.role_type = 'organisation_admin'
             AND EXISTS (
                 SELECT 1 FROM convoy.users u
                 WHERE u.id = o1.user_id
                     AND (u.auth_type = 'local' OR u.auth_type IS NULL OR u.auth_type = '')
             )
             AND NOT EXISTS (
                 SELECT 1 FROM convoy.organisation_members o3
                 JOIN convoy.users u3 ON o3.user_id = u3.id
                 WHERE o3.role_type = 'instance_admin'
                     AND o3.deleted_at IS NULL
                     AND (u3.auth_type = 'local' OR u3.auth_type IS NULL OR u3.auth_type = '')
             )
             AND o1.created_at = (
                 SELECT MIN(o4.created_at)
                 FROM convoy.organisation_members o4
                 JOIN convoy.users u2 ON o4.user_id = u2.id
                 WHERE o4.role_type = 'organisation_admin'
                     AND o4.deleted_at IS NULL
                     AND (u2.auth_type = 'local' OR u2.auth_type IS NULL OR u2.auth_type = '')
             )
            )
        )
)
`

func (q *Queries) IsFirstInstanceAdmin(ctx context.Context, userID string) (bool, error) {
	row := q.db.QueryRow(ctx, isFirstInstanceAdmin, userID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateOrganisationMember = `-- name: UpdateOrganisationMember :exec
UPDATE convoy.organisation_members
SET
    role_type = $2,
    role_project = $3,
    role_endpoint = $4,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateOrganisationMemberParams struct {
	ID           string
	RoleType     string
	RoleProject  pgtype.Text
	RoleEndpoint pgtype.Text
}

func (q *Queries) UpdateOrganisationMember(ctx context.Context, arg UpdateOrganisationMemberParams) error {
	_, err := q.db.Exec(ctx, updateOrganisationMember,
		arg.ID,
		arg.RoleType,
		arg.RoleProject,
		arg.RoleEndpoint,
	)
	return err
}
