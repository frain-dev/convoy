// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPrevOrganisationInvites = `-- name: CountPrevOrganisationInvites :one
SELECT COALESCE(COUNT(DISTINCT id), 0) AS count
FROM convoy.organisation_invites
WHERE organisation_id = $1
    AND deleted_at IS NULL
    AND id > $2
`

type CountPrevOrganisationInvitesParams struct {
	OrgID  string
	Cursor string
}

func (q *Queries) CountPrevOrganisationInvites(ctx context.Context, arg CountPrevOrganisationInvitesParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, countPrevOrganisationInvites, arg.OrgID, arg.Cursor)
	var count pgtype.Int8
	err := row.Scan(&count)
	return count, err
}

const createOrganisationInvite = `-- name: CreateOrganisationInvite :exec
INSERT INTO convoy.organisation_invites (
    id,
    organisation_id,
    invitee_email,
    token,
    role_type,
    role_project,
    role_endpoint,
    status,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
`

type CreateOrganisationInviteParams struct {
	ID             string
	OrganisationID string
	InviteeEmail   string
	Token          string
	RoleType       string
	RoleProject    pgtype.Text
	RoleEndpoint   pgtype.Text
	Status         string
	ExpiresAt      pgtype.Timestamptz
}

func (q *Queries) CreateOrganisationInvite(ctx context.Context, arg CreateOrganisationInviteParams) error {
	_, err := q.db.Exec(ctx, createOrganisationInvite,
		arg.ID,
		arg.OrganisationID,
		arg.InviteeEmail,
		arg.Token,
		arg.RoleType,
		arg.RoleProject,
		arg.RoleEndpoint,
		arg.Status,
		arg.ExpiresAt,
	)
	return err
}

const deleteOrganisationInvite = `-- name: DeleteOrganisationInvite :exec
UPDATE convoy.organisation_invites
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteOrganisationInvite(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteOrganisationInvite, id)
	return err
}

const fetchOrganisationInviteByID = `-- name: FetchOrganisationInviteByID :one
SELECT
    id,
    organisation_id,
    invitee_email,
    token,
    status,
    role_type,
    COALESCE(role_project, '') AS role_project,
    COALESCE(role_endpoint, '') AS role_endpoint,
    created_at,
    updated_at,
    expires_at
FROM convoy.organisation_invites
WHERE id = $1 AND deleted_at IS NULL
`

type FetchOrganisationInviteByIDRow struct {
	ID             string
	OrganisationID string
	InviteeEmail   string
	Token          string
	Status         string
	RoleType       string
	RoleProject    string
	RoleEndpoint   string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	ExpiresAt      pgtype.Timestamptz
}

func (q *Queries) FetchOrganisationInviteByID(ctx context.Context, id string) (FetchOrganisationInviteByIDRow, error) {
	row := q.db.QueryRow(ctx, fetchOrganisationInviteByID, id)
	var i FetchOrganisationInviteByIDRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.InviteeEmail,
		&i.Token,
		&i.Status,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const fetchOrganisationInviteByToken = `-- name: FetchOrganisationInviteByToken :one
SELECT
    id,
    organisation_id,
    invitee_email,
    token,
    status,
    role_type,
    COALESCE(role_project, '') AS role_project,
    COALESCE(role_endpoint, '') AS role_endpoint,
    created_at,
    updated_at,
    expires_at
FROM convoy.organisation_invites
WHERE token = $1 AND deleted_at IS NULL
`

type FetchOrganisationInviteByTokenRow struct {
	ID             string
	OrganisationID string
	InviteeEmail   string
	Token          string
	Status         string
	RoleType       string
	RoleProject    string
	RoleEndpoint   string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	ExpiresAt      pgtype.Timestamptz
}

func (q *Queries) FetchOrganisationInviteByToken(ctx context.Context, token string) (FetchOrganisationInviteByTokenRow, error) {
	row := q.db.QueryRow(ctx, fetchOrganisationInviteByToken, token)
	var i FetchOrganisationInviteByTokenRow
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.InviteeEmail,
		&i.Token,
		&i.Status,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const fetchOrganisationInvitesPaginated = `-- name: FetchOrganisationInvitesPaginated :many
WITH filtered_invites AS (
    SELECT
        id,
        organisation_id,
        invitee_email,
        status,
        role_type,
        COALESCE(role_project, '') AS role_project,
        COALESCE(role_endpoint, '') AS role_endpoint,
        created_at,
        updated_at,
        expires_at
    FROM convoy.organisation_invites
    WHERE organisation_id = $2
        AND status = $3
        AND deleted_at IS NULL
        -- Cursor-based pagination
        AND (
            CASE
                WHEN $1::text = 'next' THEN id <= $4
                WHEN $1::text = 'prev' THEN id >= $4
                ELSE true
            END
        )
    GROUP BY id
    -- Sort order: DESC for forward, ASC for backward
    ORDER BY
        CASE
            WHEN $1::text = 'next' THEN id
        END DESC,
        CASE
            WHEN $1::text = 'prev' THEN id
        END ASC
    LIMIT $5
)
SELECT id, organisation_id, invitee_email, status, role_type, role_project, role_endpoint, created_at, updated_at, expires_at FROM filtered_invites
ORDER BY
    CASE
        WHEN $1::text = 'prev' THEN id
    END DESC,
    CASE
        WHEN $1::text = 'next' THEN id
    END DESC
`

type FetchOrganisationInvitesPaginatedParams struct {
	Direction string
	OrgID     string
	Status    string
	Cursor    string
	LimitVal  int64
}

type FetchOrganisationInvitesPaginatedRow struct {
	ID             string
	OrganisationID string
	InviteeEmail   string
	Status         string
	RoleType       string
	RoleProject    string
	RoleEndpoint   string
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	ExpiresAt      pgtype.Timestamptz
}

// Final select: reverse order for backward pagination
func (q *Queries) FetchOrganisationInvitesPaginated(ctx context.Context, arg FetchOrganisationInvitesPaginatedParams) ([]FetchOrganisationInvitesPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchOrganisationInvitesPaginated,
		arg.Direction,
		arg.OrgID,
		arg.Status,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchOrganisationInvitesPaginatedRow
	for rows.Next() {
		var i FetchOrganisationInvitesPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.InviteeEmail,
			&i.Status,
			&i.RoleType,
			&i.RoleProject,
			&i.RoleEndpoint,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganisationInvite = `-- name: UpdateOrganisationInvite :exec
UPDATE convoy.organisation_invites
SET
    role_type = $2,
    role_project = $3,
    role_endpoint = $4,
    status = $5,
    expires_at = $6,
    updated_at = NOW(),
    deleted_at = $7
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateOrganisationInviteParams struct {
	ID           string
	RoleType     string
	RoleProject  pgtype.Text
	RoleEndpoint pgtype.Text
	Status       string
	ExpiresAt    pgtype.Timestamptz
	DeletedAt    pgtype.Timestamptz
}

func (q *Queries) UpdateOrganisationInvite(ctx context.Context, arg UpdateOrganisationInviteParams) error {
	_, err := q.db.Exec(ctx, updateOrganisationInvite,
		arg.ID,
		arg.RoleType,
		arg.RoleProject,
		arg.RoleEndpoint,
		arg.Status,
		arg.ExpiresAt,
		arg.DeletedAt,
	)
	return err
}
