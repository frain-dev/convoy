// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPrevAPIKeys = `-- name: CountPrevAPIKeys :one
SELECT COALESCE(COUNT(DISTINCT id), 0) AS count
FROM convoy.api_keys
WHERE deleted_at IS NULL
    AND id > $1
    -- Apply same filters as pagination query
    AND ($2 = '' OR role_project = $2)
    AND ($3 = '' OR role_endpoint = $3)
    AND ($4 = '' OR user_id = $4)
    AND ($5 = '' OR key_type = $5)
    AND (
        CASE
            WHEN $6::boolean THEN role_endpoint = ANY($7::text[])
            ELSE true
        END
    )
`

type CountPrevAPIKeysParams struct {
	Cursor         string
	ProjectID      pgtype.Text
	EndpointID     pgtype.Text
	UserID         pgtype.Text
	KeyType        pgtype.Text
	HasEndpointIds bool
	EndpointIds    []string
}

// Count records before the given cursor (for pagination metadata)
// Uses same filters as FetchAPIKeysPaginated
//
// This query counts how many records exist with ID > cursor
// which tells us how many records are on previous pages
func (q *Queries) CountPrevAPIKeys(ctx context.Context, arg CountPrevAPIKeysParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, countPrevAPIKeys,
		arg.Cursor,
		arg.ProjectID,
		arg.EndpointID,
		arg.UserID,
		arg.KeyType,
		arg.HasEndpointIds,
		arg.EndpointIds,
	)
	var count pgtype.Int8
	err := row.Scan(&count)
	return count, err
}

const createAPIKey = `-- name: CreateAPIKey :exec


INSERT INTO convoy.api_keys (
    id, name, key_type, mask_id,
    role_type, role_project, role_endpoint,
    hash, salt, user_id, expires_at
)
VALUES (
    $1, $2, $3, $4,
    $5, $6, $7,
    $8, $9, $10, $11
)
`

type CreateAPIKeyParams struct {
	ID           string
	Name         string
	KeyType      string
	MaskID       string
	RoleType     pgtype.Text
	RoleProject  pgtype.Text
	RoleEndpoint pgtype.Text
	Hash         string
	Salt         string
	UserID       pgtype.Text
	ExpiresAt    pgtype.Timestamptz
}

// API Keys Queries
// Schema: convoy.api_keys
// Columns: id, name, key_type, mask_id, role_type, role_project, role_endpoint,
//
//	hash, salt, user_id, expires_at, created_at, updated_at, deleted_at
//
// ============================================================================
// CREATE Operations
// ============================================================================
func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) error {
	_, err := q.db.Exec(ctx, createAPIKey,
		arg.ID,
		arg.Name,
		arg.KeyType,
		arg.MaskID,
		arg.RoleType,
		arg.RoleProject,
		arg.RoleEndpoint,
		arg.Hash,
		arg.Salt,
		arg.UserID,
		arg.ExpiresAt,
	)
	return err
}

const fetchAPIKeysPaginated = `-- name: FetchAPIKeysPaginated :many

WITH filtered_api_keys AS (
    SELECT
        id,
        name,
        key_type,
        mask_id,
        COALESCE(role_type, '') AS role_type,
        COALESCE(role_project, '') AS role_project,
        COALESCE(role_endpoint, '') AS role_endpoint,
        hash,
        salt,
        COALESCE(user_id, '') AS user_id,
        created_at,
        updated_at,
        expires_at,
        deleted_at
    FROM convoy.api_keys
    WHERE deleted_at IS NULL
        -- Cursor-based pagination: < for forward (next), > for backward (prev)
        -- Skip cursor check if cursor is empty (first page)
        AND (
            CASE
                WHEN $2 = '' THEN true
                WHEN $1::text = 'next' THEN id < $2
                WHEN $1::text = 'prev' THEN id > $2
                ELSE true
            END
        )
        -- Optional filters: apply only if value is not empty string
        AND ($3 = '' OR role_project = $3)
        AND ($4 = '' OR role_endpoint = $4)
        AND ($5 = '' OR user_id = $5)
        AND ($6 = '' OR key_type = $6)
        -- Array filter: apply only if has_endpoint_ids is true
        AND (
            CASE
                WHEN $7::boolean THEN role_endpoint = ANY($8::text[])
                ELSE true
            END
        )
    GROUP BY id
    -- Sort order: DESC for forward (next), ASC for backward (prev)
    -- This ensures we get the right direction for cursor-based pagination
    ORDER BY
        CASE WHEN $1::text = 'next' THEN id END DESC,
        CASE WHEN $1::text = 'prev' THEN id END ASC
    LIMIT $9
)
SELECT id, name, key_type, mask_id, role_type, role_project, role_endpoint, hash, salt, user_id, created_at, updated_at, expires_at, deleted_at FROM filtered_api_keys
ORDER BY
    CASE WHEN $1::text = 'prev' THEN id END DESC,
    CASE WHEN $1::text = 'next' THEN id END DESC
`

type FetchAPIKeysPaginatedParams struct {
	Direction      string
	Cursor         pgtype.Text
	ProjectID      pgtype.Text
	EndpointID     pgtype.Text
	UserID         pgtype.Text
	KeyType        pgtype.Text
	HasEndpointIds bool
	EndpointIds    []string
	LimitVal       int64
}

type FetchAPIKeysPaginatedRow struct {
	ID           string
	Name         string
	KeyType      string
	MaskID       string
	RoleType     string
	RoleProject  string
	RoleEndpoint string
	Hash         string
	Salt         string
	UserID       string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	ExpiresAt    pgtype.Timestamptz
	DeletedAt    pgtype.Timestamptz
}

// ============================================================================
// PAGINATED READ Operations
// ============================================================================
// Unified pagination query that handles:
// - Bidirectional pagination (forward with 'next', backward with 'prev')
// - Multiple optional filters (project_id, endpoint_id, user_id, key_type)
// - Array filter for endpoint_ids
// - Soft delete filtering (deleted_at IS NULL)
//
// Parameters:
// @direction: 'next' for forward pagination, 'prev' for backward pagination
// @cursor: ID of the last item from previous page (empty string for first page)
// @project_id: Filter by role_project (empty string to skip)
// @endpoint_id: Filter by single role_endpoint (empty string to skip)
// @user_id: Filter by user_id (empty string to skip)
// @key_type: Filter by key_type (empty string to skip)
// @has_endpoint_ids: true to filter by endpoint_ids array, false to skip
// @endpoint_ids: Array of endpoint IDs to filter by
// @limit_val: Number of records to fetch (should be PerPage + 1 for hasNext detection)
// Final select: reverse order for backward pagination to maintain DESC ordering
func (q *Queries) FetchAPIKeysPaginated(ctx context.Context, arg FetchAPIKeysPaginatedParams) ([]FetchAPIKeysPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchAPIKeysPaginated,
		arg.Direction,
		arg.Cursor,
		arg.ProjectID,
		arg.EndpointID,
		arg.UserID,
		arg.KeyType,
		arg.HasEndpointIds,
		arg.EndpointIds,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchAPIKeysPaginatedRow
	for rows.Next() {
		var i FetchAPIKeysPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.KeyType,
			&i.MaskID,
			&i.RoleType,
			&i.RoleProject,
			&i.RoleEndpoint,
			&i.Hash,
			&i.Salt,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExpiresAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAPIKeyByHash = `-- name: FindAPIKeyByHash :one
SELECT
    id,
    name,
    key_type,
    mask_id,
    COALESCE(role_type, '') AS role_type,
    COALESCE(role_project, '') AS role_project,
    COALESCE(role_endpoint, '') AS role_endpoint,
    hash,
    salt,
    COALESCE(user_id, '') AS user_id,
    created_at,
    updated_at,
    expires_at,
    deleted_at
FROM convoy.api_keys
WHERE hash = $1 AND deleted_at IS NULL
`

type FindAPIKeyByHashRow struct {
	ID           string
	Name         string
	KeyType      string
	MaskID       string
	RoleType     string
	RoleProject  string
	RoleEndpoint string
	Hash         string
	Salt         string
	UserID       string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	ExpiresAt    pgtype.Timestamptz
	DeletedAt    pgtype.Timestamptz
}

func (q *Queries) FindAPIKeyByHash(ctx context.Context, hash string) (FindAPIKeyByHashRow, error) {
	row := q.db.QueryRow(ctx, findAPIKeyByHash, hash)
	var i FindAPIKeyByHashRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.KeyType,
		&i.MaskID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.Hash,
		&i.Salt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
	)
	return i, err
}

const findAPIKeyByID = `-- name: FindAPIKeyByID :one

SELECT
    id,
    name,
    key_type,
    mask_id,
    COALESCE(role_type, '') AS role_type,
    COALESCE(role_project, '') AS role_project,
    COALESCE(role_endpoint, '') AS role_endpoint,
    hash,
    salt,
    COALESCE(user_id, '') AS user_id,
    created_at,
    updated_at,
    expires_at,
    deleted_at
FROM convoy.api_keys
WHERE id = $1 AND deleted_at IS NULL
`

type FindAPIKeyByIDRow struct {
	ID           string
	Name         string
	KeyType      string
	MaskID       string
	RoleType     string
	RoleProject  string
	RoleEndpoint string
	Hash         string
	Salt         string
	UserID       string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	ExpiresAt    pgtype.Timestamptz
	DeletedAt    pgtype.Timestamptz
}

// ============================================================================
// READ Operations - Single Record
// ============================================================================
func (q *Queries) FindAPIKeyByID(ctx context.Context, id string) (FindAPIKeyByIDRow, error) {
	row := q.db.QueryRow(ctx, findAPIKeyByID, id)
	var i FindAPIKeyByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.KeyType,
		&i.MaskID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.Hash,
		&i.Salt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
	)
	return i, err
}

const findAPIKeyByMaskID = `-- name: FindAPIKeyByMaskID :one
SELECT
    id,
    name,
    key_type,
    mask_id,
    COALESCE(role_type, '') AS role_type,
    COALESCE(role_project, '') AS role_project,
    COALESCE(role_endpoint, '') AS role_endpoint,
    hash,
    salt,
    COALESCE(user_id, '') AS user_id,
    created_at,
    updated_at,
    expires_at,
    deleted_at
FROM convoy.api_keys
WHERE mask_id = $1
`

type FindAPIKeyByMaskIDRow struct {
	ID           string
	Name         string
	KeyType      string
	MaskID       string
	RoleType     string
	RoleProject  string
	RoleEndpoint string
	Hash         string
	Salt         string
	UserID       string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	ExpiresAt    pgtype.Timestamptz
	DeletedAt    pgtype.Timestamptz
}

// CRITICAL: Used for API key authentication in NativeRealm
func (q *Queries) FindAPIKeyByMaskID(ctx context.Context, maskID string) (FindAPIKeyByMaskIDRow, error) {
	row := q.db.QueryRow(ctx, findAPIKeyByMaskID, maskID)
	var i FindAPIKeyByMaskIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.KeyType,
		&i.MaskID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.Hash,
		&i.Salt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
	)
	return i, err
}

const findAPIKeyByProjectID = `-- name: FindAPIKeyByProjectID :one
SELECT
    id,
    name,
    key_type,
    mask_id,
    COALESCE(role_type, '') AS role_type,
    COALESCE(role_project, '') AS role_project,
    COALESCE(role_endpoint, '') AS role_endpoint,
    hash,
    salt,
    COALESCE(user_id, '') AS user_id,
    created_at,
    updated_at,
    expires_at,
    deleted_at
FROM convoy.api_keys
WHERE role_project = $1 AND deleted_at IS NULL
`

type FindAPIKeyByProjectIDRow struct {
	ID           string
	Name         string
	KeyType      string
	MaskID       string
	RoleType     string
	RoleProject  string
	RoleEndpoint string
	Hash         string
	Salt         string
	UserID       string
	CreatedAt    pgtype.Timestamptz
	UpdatedAt    pgtype.Timestamptz
	ExpiresAt    pgtype.Timestamptz
	DeletedAt    pgtype.Timestamptz
}

func (q *Queries) FindAPIKeyByProjectID(ctx context.Context, roleProject pgtype.Text) (FindAPIKeyByProjectIDRow, error) {
	row := q.db.QueryRow(ctx, findAPIKeyByProjectID, roleProject)
	var i FindAPIKeyByProjectIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.KeyType,
		&i.MaskID,
		&i.RoleType,
		&i.RoleProject,
		&i.RoleEndpoint,
		&i.Hash,
		&i.Salt,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExpiresAt,
		&i.DeletedAt,
	)
	return i, err
}

const revokeAPIKeys = `-- name: RevokeAPIKeys :exec

UPDATE convoy.api_keys
SET deleted_at = NOW()
WHERE id = ANY($1::text[]) AND deleted_at IS NULL
`

// ============================================================================
// DELETE Operations (Soft Delete)
// ============================================================================
// Soft delete multiple API keys by setting deleted_at timestamp
// Uses ANY() for array parameter handling
func (q *Queries) RevokeAPIKeys(ctx context.Context, ids []string) error {
	_, err := q.db.Exec(ctx, revokeAPIKeys, ids)
	return err
}

const updateAPIKey = `-- name: UpdateAPIKey :exec

UPDATE convoy.api_keys
SET
    name = $1,
    role_type = $2,
    role_project = $3,
    role_endpoint = $4,
    updated_at = NOW()
WHERE id = $5 AND deleted_at IS NULL
`

type UpdateAPIKeyParams struct {
	Name         string
	RoleType     pgtype.Text
	RoleProject  pgtype.Text
	RoleEndpoint pgtype.Text
	ID           string
}

// ============================================================================
// UPDATE Operations
// ============================================================================
func (q *Queries) UpdateAPIKey(ctx context.Context, arg UpdateAPIKeyParams) error {
	_, err := q.db.Exec(ctx, updateAPIKey,
		arg.Name,
		arg.RoleType,
		arg.RoleProject,
		arg.RoleEndpoint,
		arg.ID,
	)
	return err
}
