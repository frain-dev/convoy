// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const calculateEgressBytes = `-- name: CalculateEgressBytes :one
SELECT COALESCE(SUM(LENGTH(e.raw)), 0) + COALESCE(SUM(OCTET_LENGTH(e.data::text)), 0) AS bytes
FROM convoy.event_deliveries d
JOIN convoy.events e ON e.id = d.event_id
JOIN convoy.projects p ON p.id = e.project_id
WHERE p.organisation_id = $1
  AND d.status = 'Success'
  AND d.created_at >= $2
  AND d.created_at <= $3
  AND p.deleted_at IS NULL
`

type CalculateEgressBytesParams struct {
	OrganisationID string
	CreatedAt      pgtype.Timestamptz
	CreatedAt_2    pgtype.Timestamptz
}

func (q *Queries) CalculateEgressBytes(ctx context.Context, arg CalculateEgressBytesParams) (int64, error) {
	row := q.db.QueryRow(ctx, calculateEgressBytes, arg.OrganisationID, arg.CreatedAt, arg.CreatedAt_2)
	var bytes int64
	err := row.Scan(&bytes)
	return bytes, err
}

const calculateIngressBytes = `-- name: CalculateIngressBytes :one

SELECT
    COALESCE(SUM(LENGTH(e.raw)), 0) AS raw_bytes,
    COALESCE(SUM(OCTET_LENGTH(e.data::text)), 0) AS data_bytes
FROM convoy.events e
JOIN convoy.projects p ON p.id = e.project_id
WHERE p.organisation_id = $1
  AND e.created_at >= $2
  AND e.created_at <= $3
  AND e.deleted_at IS NULL
  AND p.deleted_at IS NULL
`

type CalculateIngressBytesParams struct {
	OrganisationID string
	CreatedAt      pgtype.Timestamptz
	CreatedAt_2    pgtype.Timestamptz
}

type CalculateIngressBytesRow struct {
	RawBytes  pgtype.Int8
	DataBytes pgtype.Int8
}

// Usage Calculation Queries
func (q *Queries) CalculateIngressBytes(ctx context.Context, arg CalculateIngressBytesParams) (CalculateIngressBytesRow, error) {
	row := q.db.QueryRow(ctx, calculateIngressBytes, arg.OrganisationID, arg.CreatedAt, arg.CreatedAt_2)
	var i CalculateIngressBytesRow
	err := row.Scan(&i.RawBytes, &i.DataBytes)
	return i, err
}

const countOrgDeliveries = `-- name: CountOrgDeliveries :one
SELECT COUNT(*) AS count
FROM convoy.event_deliveries d
JOIN convoy.events e ON e.id = d.event_id
JOIN convoy.projects p ON p.id = e.project_id
WHERE p.organisation_id = $1
  AND d.status = 'Success'
  AND d.created_at >= $2
  AND d.created_at <= $3
  AND p.deleted_at IS NULL
`

type CountOrgDeliveriesParams struct {
	OrganisationID string
	CreatedAt      pgtype.Timestamptz
	CreatedAt_2    pgtype.Timestamptz
}

func (q *Queries) CountOrgDeliveries(ctx context.Context, arg CountOrgDeliveriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrgDeliveries, arg.OrganisationID, arg.CreatedAt, arg.CreatedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrgEvents = `-- name: CountOrgEvents :one
SELECT COUNT(*) AS count
FROM convoy.events e
JOIN convoy.projects p ON p.id = e.project_id
WHERE p.organisation_id = $1
  AND e.created_at >= $2
  AND e.created_at <= $3
  AND e.deleted_at IS NULL
  AND p.deleted_at IS NULL
`

type CountOrgEventsParams struct {
	OrganisationID string
	CreatedAt      pgtype.Timestamptz
	CreatedAt_2    pgtype.Timestamptz
}

func (q *Queries) CountOrgEvents(ctx context.Context, arg CountOrgEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countOrgEvents, arg.OrganisationID, arg.CreatedAt, arg.CreatedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOrganisations = `-- name: CountOrganisations :one
SELECT COUNT(*) AS count
FROM convoy.organisations
WHERE deleted_at IS NULL
`

func (q *Queries) CountOrganisations(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOrganisations)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrevOrganisations = `-- name: CountPrevOrganisations :one
SELECT COALESCE(COUNT(DISTINCT id), 0) AS count
FROM convoy.organisations
WHERE deleted_at IS NULL
    -- Same search filter as main query
    AND (
        CASE
            WHEN $1::boolean THEN
                (LOWER(name) LIKE LOWER($2) OR LOWER(id) LIKE LOWER($2))
            ELSE true
        END
    )
    -- Count items with ID greater than cursor (items before current page)
    AND id > $3
`

type CountPrevOrganisationsParams struct {
	HasSearch bool
	Search    string
	Cursor    string
}

func (q *Queries) CountPrevOrganisations(ctx context.Context, arg CountPrevOrganisationsParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, countPrevOrganisations, arg.HasSearch, arg.Search, arg.Cursor)
	var count pgtype.Int8
	err := row.Scan(&count)
	return count, err
}

const createOrganisation = `-- name: CreateOrganisation :exec

INSERT INTO convoy.organisations (
    id,
    name,
    owner_id,
    custom_domain,
    assigned_domain,
    license_data
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
)
`

type CreateOrganisationParams struct {
	ID             string
	Name           string
	OwnerID        string
	CustomDomain   pgtype.Text
	AssignedDomain pgtype.Text
	LicenseData    pgtype.Text
}

// Organisation Repository SQLc Queries
// This file contains all SQL queries for organisation operations
func (q *Queries) CreateOrganisation(ctx context.Context, arg CreateOrganisationParams) error {
	_, err := q.db.Exec(ctx, createOrganisation,
		arg.ID,
		arg.Name,
		arg.OwnerID,
		arg.CustomDomain,
		arg.AssignedDomain,
		arg.LicenseData,
	)
	return err
}

const deleteOrganisation = `-- name: DeleteOrganisation :execresult
UPDATE convoy.organisations
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) DeleteOrganisation(ctx context.Context, id string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteOrganisation, id)
}

const fetchOrganisationByAssignedDomain = `-- name: FetchOrganisationByAssignedDomain :one
SELECT
    id,
    owner_id,
    name,
    custom_domain,
    assigned_domain,
    license_data,
    created_at,
    updated_at,
    deleted_at,
    disabled_at
FROM convoy.organisations
WHERE assigned_domain = $1
  AND deleted_at IS NULL
`

type FetchOrganisationByAssignedDomainRow struct {
	ID             string
	OwnerID        string
	Name           string
	CustomDomain   pgtype.Text
	AssignedDomain pgtype.Text
	LicenseData    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	DisabledAt     pgtype.Timestamptz
}

func (q *Queries) FetchOrganisationByAssignedDomain(ctx context.Context, assignedDomain pgtype.Text) (FetchOrganisationByAssignedDomainRow, error) {
	row := q.db.QueryRow(ctx, fetchOrganisationByAssignedDomain, assignedDomain)
	var i FetchOrganisationByAssignedDomainRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.CustomDomain,
		&i.AssignedDomain,
		&i.LicenseData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DisabledAt,
	)
	return i, err
}

const fetchOrganisationByCustomDomain = `-- name: FetchOrganisationByCustomDomain :one
SELECT
    id,
    owner_id,
    name,
    custom_domain,
    assigned_domain,
    license_data,
    created_at,
    updated_at,
    deleted_at,
    disabled_at
FROM convoy.organisations
WHERE custom_domain = $1
  AND deleted_at IS NULL
`

type FetchOrganisationByCustomDomainRow struct {
	ID             string
	OwnerID        string
	Name           string
	CustomDomain   pgtype.Text
	AssignedDomain pgtype.Text
	LicenseData    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	DisabledAt     pgtype.Timestamptz
}

func (q *Queries) FetchOrganisationByCustomDomain(ctx context.Context, customDomain pgtype.Text) (FetchOrganisationByCustomDomainRow, error) {
	row := q.db.QueryRow(ctx, fetchOrganisationByCustomDomain, customDomain)
	var i FetchOrganisationByCustomDomainRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.CustomDomain,
		&i.AssignedDomain,
		&i.LicenseData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DisabledAt,
	)
	return i, err
}

const fetchOrganisationByID = `-- name: FetchOrganisationByID :one
SELECT
    id,
    owner_id,
    name,
    custom_domain,
    assigned_domain,
    license_data,
    created_at,
    updated_at,
    deleted_at,
    disabled_at
FROM convoy.organisations
WHERE id = $1
  AND deleted_at IS NULL
`

type FetchOrganisationByIDRow struct {
	ID             string
	OwnerID        string
	Name           string
	CustomDomain   pgtype.Text
	AssignedDomain pgtype.Text
	LicenseData    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	DisabledAt     pgtype.Timestamptz
}

func (q *Queries) FetchOrganisationByID(ctx context.Context, id string) (FetchOrganisationByIDRow, error) {
	row := q.db.QueryRow(ctx, fetchOrganisationByID, id)
	var i FetchOrganisationByIDRow
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.Name,
		&i.CustomDomain,
		&i.AssignedDomain,
		&i.LicenseData,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.DisabledAt,
	)
	return i, err
}

const fetchOrganisationsPaginated = `-- name: FetchOrganisationsPaginated :many
WITH filtered_organisations AS (
    SELECT
        id,
        owner_id,
        name,
        custom_domain,
        assigned_domain,
        license_data,
        created_at,
        updated_at,
        deleted_at,
        disabled_at
    FROM convoy.organisations
    WHERE deleted_at IS NULL
        -- Optional search filter (searches both name and id)
        AND (
            CASE
                WHEN $2::boolean THEN
                    (LOWER(name) LIKE LOWER($3) OR LOWER(id) LIKE LOWER($3))
                ELSE true
            END
        )
        -- Cursor-based pagination
        AND (
            CASE
                WHEN $1::text = 'next' THEN id <= $4
                WHEN $1::text = 'prev' THEN id >= $4
                ELSE true
            END
        )
    -- Sort order: DESC for forward, ASC for backward
    ORDER BY
        CASE WHEN $1::text = 'next' THEN id END DESC,
        CASE WHEN $1::text = 'prev' THEN id END ASC
    LIMIT $5
)
SELECT id, owner_id, name, custom_domain, assigned_domain, license_data, created_at, updated_at, deleted_at, disabled_at FROM filtered_organisations
ORDER BY
    CASE WHEN $1::text = 'prev' THEN id END DESC,
    CASE WHEN $1::text = 'next' THEN id END DESC
`

type FetchOrganisationsPaginatedParams struct {
	Direction string
	HasSearch bool
	Search    string
	Cursor    string
	LimitVal  int64
}

type FetchOrganisationsPaginatedRow struct {
	ID             string
	OwnerID        string
	Name           string
	CustomDomain   pgtype.Text
	AssignedDomain pgtype.Text
	LicenseData    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	DisabledAt     pgtype.Timestamptz
}

// Final select: reverse order for backward pagination
func (q *Queries) FetchOrganisationsPaginated(ctx context.Context, arg FetchOrganisationsPaginatedParams) ([]FetchOrganisationsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchOrganisationsPaginated,
		arg.Direction,
		arg.HasSearch,
		arg.Search,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchOrganisationsPaginatedRow
	for rows.Next() {
		var i FetchOrganisationsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.Name,
			&i.CustomDomain,
			&i.AssignedDomain,
			&i.LicenseData,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.DisabledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrganisation = `-- name: UpdateOrganisation :execresult
UPDATE convoy.organisations
SET
    name = $2,
    custom_domain = $3,
    assigned_domain = $4,
    disabled_at = $5,
    license_data = $6,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type UpdateOrganisationParams struct {
	ID             string
	Name           string
	CustomDomain   pgtype.Text
	AssignedDomain pgtype.Text
	DisabledAt     pgtype.Timestamptz
	LicenseData    pgtype.Text
}

func (q *Queries) UpdateOrganisation(ctx context.Context, arg UpdateOrganisationParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateOrganisation,
		arg.ID,
		arg.Name,
		arg.CustomDomain,
		arg.AssignedDomain,
		arg.DisabledAt,
		arg.LicenseData,
	)
}

const updateOrganisationLicenseData = `-- name: UpdateOrganisationLicenseData :execresult
UPDATE convoy.organisations
SET license_data = $2,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type UpdateOrganisationLicenseDataParams struct {
	ID          string
	LicenseData pgtype.Text
}

func (q *Queries) UpdateOrganisationLicenseData(ctx context.Context, arg UpdateOrganisationLicenseDataParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateOrganisationLicenseData, arg.ID, arg.LicenseData)
}
