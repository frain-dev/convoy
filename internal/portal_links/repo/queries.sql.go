// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkWritePortalAuthTokens = `-- name: BulkWritePortalAuthTokens :exec
INSERT INTO convoy.portal_tokens (id, portal_link_id, token_mask_id, token_hash, token_salt, token_expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type BulkWritePortalAuthTokensParams struct {
	ID             string
	PortalLinkID   string
	TokenMaskID    pgtype.Text
	TokenHash      pgtype.Text
	TokenSalt      pgtype.Text
	TokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) BulkWritePortalAuthTokens(ctx context.Context, arg BulkWritePortalAuthTokensParams) error {
	_, err := q.db.Exec(ctx, bulkWritePortalAuthTokens,
		arg.ID,
		arg.PortalLinkID,
		arg.TokenMaskID,
		arg.TokenHash,
		arg.TokenSalt,
		arg.TokenExpiresAt,
	)
	return err
}

const countPrevPortalLinks = `-- name: CountPrevPortalLinks :one
SELECT COUNT(DISTINCT(p.id)) AS count
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.deleted_at IS NULL
    AND (p.project_id = $1 OR $1 = '')
    AND p.id > $2
GROUP BY p.id
ORDER BY p.id DESC
LIMIT 1
`

type CountPrevPortalLinksParams struct {
	ProjectID string
	Cursor    string
}

func (q *Queries) CountPrevPortalLinks(ctx context.Context, arg CountPrevPortalLinksParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPrevPortalLinks, arg.ProjectID, arg.Cursor)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrevPortalLinksWithEndpointFilter = `-- name: CountPrevPortalLinksWithEndpointFilter :one
SELECT COUNT(DISTINCT(p.id)) AS count
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.deleted_at IS NULL
    AND (p.project_id = $1 OR $1 = '')
    AND pe.endpoint_id = ANY($2::text[])
    AND p.id > $3
GROUP BY p.id
ORDER BY p.id DESC
LIMIT 1
`

type CountPrevPortalLinksWithEndpointFilterParams struct {
	ProjectID   string
	EndpointIds []string
	Cursor      string
}

func (q *Queries) CountPrevPortalLinksWithEndpointFilter(ctx context.Context, arg CountPrevPortalLinksWithEndpointFilterParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPrevPortalLinksWithEndpointFilter, arg.ProjectID, arg.EndpointIds, arg.Cursor)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPortalLink = `-- name: CreatePortalLink :exec

INSERT INTO convoy.portal_links (id, project_id, name, token, endpoints, owner_id, can_manage_endpoint, auth_type)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreatePortalLinkParams struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	OwnerID           pgtype.Text
	CanManageEndpoint pgtype.Bool
	AuthType          ConvoyPortalAuthTypes
}

// Portal Links Queries
func (q *Queries) CreatePortalLink(ctx context.Context, arg CreatePortalLinkParams) error {
	_, err := q.db.Exec(ctx, createPortalLink,
		arg.ID,
		arg.ProjectID,
		arg.Name,
		arg.Token,
		arg.Endpoints,
		arg.OwnerID,
		arg.CanManageEndpoint,
		arg.AuthType,
	)
	return err
}

const createPortalLinkAuthToken = `-- name: CreatePortalLinkAuthToken :exec
INSERT INTO convoy.portal_tokens (id, portal_link_id, token_mask_id, token_hash, token_salt, token_expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreatePortalLinkAuthTokenParams struct {
	ID             string
	PortalLinkID   string
	TokenMaskID    pgtype.Text
	TokenHash      pgtype.Text
	TokenSalt      pgtype.Text
	TokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreatePortalLinkAuthToken(ctx context.Context, arg CreatePortalLinkAuthTokenParams) error {
	_, err := q.db.Exec(ctx, createPortalLinkAuthToken,
		arg.ID,
		arg.PortalLinkID,
		arg.TokenMaskID,
		arg.TokenHash,
		arg.TokenSalt,
		arg.TokenExpiresAt,
	)
	return err
}

const createPortalLinkEndpoint = `-- name: CreatePortalLinkEndpoint :exec
INSERT INTO convoy.portal_links_endpoints (portal_link_id, endpoint_id)
VALUES ($1, $2)
`

type CreatePortalLinkEndpointParams struct {
	PortalLinkID string
	EndpointID   string
}

func (q *Queries) CreatePortalLinkEndpoint(ctx context.Context, arg CreatePortalLinkEndpointParams) error {
	_, err := q.db.Exec(ctx, createPortalLinkEndpoint, arg.PortalLinkID, arg.EndpointID)
	return err
}

const deletePortalLink = `-- name: DeletePortalLink :exec
UPDATE convoy.portal_links
SET deleted_at = NOW()
WHERE id = $1 AND project_id = $2 AND deleted_at IS NULL
`

type DeletePortalLinkParams struct {
	ID        string
	ProjectID string
}

func (q *Queries) DeletePortalLink(ctx context.Context, arg DeletePortalLinkParams) error {
	_, err := q.db.Exec(ctx, deletePortalLink, arg.ID, arg.ProjectID)
	return err
}

const deletePortalLinkEndpoints = `-- name: DeletePortalLinkEndpoints :exec
DELETE FROM convoy.portal_links_endpoints
WHERE portal_link_id = $1 OR endpoint_id = $2
`

type DeletePortalLinkEndpointsParams struct {
	PortalLinkID string
	EndpointID   string
}

func (q *Queries) DeletePortalLinkEndpoints(ctx context.Context, arg DeletePortalLinkEndpointsParams) error {
	_, err := q.db.Exec(ctx, deletePortalLinkEndpoints, arg.PortalLinkID, arg.EndpointID)
	return err
}

const fetchPortalLinkById = `-- name: FetchPortalLinkById :one
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.id = $1 AND p.project_id = $2 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinkByIdParams struct {
	ID        string
	ProjectID string
}

type FetchPortalLinkByIdRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinkById(ctx context.Context, arg FetchPortalLinkByIdParams) (FetchPortalLinkByIdRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkById, arg.ID, arg.ProjectID)
	var i FetchPortalLinkByIdRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndpointsMetadata,
	)
	return i, err
}

const fetchPortalLinkByMaskId = `-- name: FetchPortalLinkByMaskId :one
SELECT
    pl.id,
    pl.project_id,
    pt.token_salt,
    pt.token_mask_id,
    pt.token_expires_at,
    pt.token_hash,
    pl.name,
    pl.token,
    pl.endpoints,
    pl.auth_type,
    COALESCE(pl.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(pl.owner_id, '') AS owner_id,
    CASE
        WHEN pl.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = pl.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = pl.id)
    END AS endpoint_count
FROM convoy.portal_tokens pt
JOIN convoy.portal_links pl ON pl.id = pt.portal_link_id
WHERE pt.token_mask_id = $1
`

type FetchPortalLinkByMaskIdRow struct {
	ID                string
	ProjectID         string
	TokenSalt         pgtype.Text
	TokenMaskID       pgtype.Text
	TokenExpiresAt    pgtype.Timestamptz
	TokenHash         pgtype.Text
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
}

func (q *Queries) FetchPortalLinkByMaskId(ctx context.Context, tokenMaskID pgtype.Text) (FetchPortalLinkByMaskIdRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkByMaskId, tokenMaskID)
	var i FetchPortalLinkByMaskIdRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.TokenSalt,
		&i.TokenMaskID,
		&i.TokenExpiresAt,
		&i.TokenHash,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
	)
	return i, err
}

const fetchPortalLinkByOwnerID = `-- name: FetchPortalLinkByOwnerID :one
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.owner_id = $1 AND p.project_id = $2 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinkByOwnerIDParams struct {
	OwnerID   pgtype.Text
	ProjectID string
}

type FetchPortalLinkByOwnerIDRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinkByOwnerID(ctx context.Context, arg FetchPortalLinkByOwnerIDParams) (FetchPortalLinkByOwnerIDRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkByOwnerID, arg.OwnerID, arg.ProjectID)
	var i FetchPortalLinkByOwnerIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndpointsMetadata,
	)
	return i, err
}

const fetchPortalLinkByToken = `-- name: FetchPortalLinkByToken :one
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.token = $1 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinkByTokenRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinkByToken(ctx context.Context, token string) (FetchPortalLinkByTokenRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkByToken, token)
	var i FetchPortalLinkByTokenRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndpointsMetadata,
	)
	return i, err
}

const fetchPortalLinksByOwnerID = `-- name: FetchPortalLinksByOwnerID :many
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.owner_id = $1 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinksByOwnerIDRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinksByOwnerID(ctx context.Context, ownerID pgtype.Text) ([]FetchPortalLinksByOwnerIDRow, error) {
	rows, err := q.db.Query(ctx, fetchPortalLinksByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPortalLinksByOwnerIDRow
	for rows.Next() {
		var i FetchPortalLinksByOwnerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Token,
			&i.Endpoints,
			&i.AuthType,
			&i.CanManageEndpoint,
			&i.OwnerID,
			&i.EndpointCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointsMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPortalLinksPaginatedBackward = `-- name: FetchPortalLinksPaginatedBackward :many
WITH portal_links AS (
    SELECT
        p.id,
        p.project_id,
        p.name,
        p.token,
        p.endpoints,
        p.auth_type,
        COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
        COALESCE(p.owner_id, '') AS owner_id,
        CASE
            WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
            ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
        END AS endpoint_count,
        p.created_at,
        p.updated_at,
        ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
            CASE WHEN e.id IS NOT NULL THEN
                cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
            END
        )) AS endpoints_metadata
    FROM convoy.portal_links p
    LEFT JOIN convoy.portal_links_endpoints pe
        ON p.id = pe.portal_link_id
    LEFT JOIN convoy.endpoints e
        ON e.id = pe.endpoint_id
    WHERE p.deleted_at IS NULL
        AND (p.project_id = $1 OR $1 = '')
        AND p.id >= $2
    GROUP BY p.id
    ORDER BY p.id ASC
    LIMIT $3
)
SELECT id, project_id, name, token, endpoints, auth_type, can_manage_endpoint, owner_id, endpoint_count, created_at, updated_at, endpoints_metadata FROM portal_links ORDER BY id DESC
`

type FetchPortalLinksPaginatedBackwardParams struct {
	ProjectID string
	Cursor    string
	LimitVal  int64
}

type FetchPortalLinksPaginatedBackwardRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinksPaginatedBackward(ctx context.Context, arg FetchPortalLinksPaginatedBackwardParams) ([]FetchPortalLinksPaginatedBackwardRow, error) {
	rows, err := q.db.Query(ctx, fetchPortalLinksPaginatedBackward, arg.ProjectID, arg.Cursor, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPortalLinksPaginatedBackwardRow
	for rows.Next() {
		var i FetchPortalLinksPaginatedBackwardRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Token,
			&i.Endpoints,
			&i.AuthType,
			&i.CanManageEndpoint,
			&i.OwnerID,
			&i.EndpointCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointsMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPortalLinksPaginatedBackwardWithEndpointFilter = `-- name: FetchPortalLinksPaginatedBackwardWithEndpointFilter :many
WITH portal_links AS (
    SELECT
        p.id,
        p.project_id,
        p.name,
        p.token,
        p.endpoints,
        p.auth_type,
        COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
        COALESCE(p.owner_id, '') AS owner_id,
        CASE
            WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
            ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
        END AS endpoint_count,
        p.created_at,
        p.updated_at,
        ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
            CASE WHEN e.id IS NOT NULL THEN
                cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
            END
        )) AS endpoints_metadata
    FROM convoy.portal_links p
    LEFT JOIN convoy.portal_links_endpoints pe
        ON p.id = pe.portal_link_id
    LEFT JOIN convoy.endpoints e
        ON e.id = pe.endpoint_id
    WHERE p.deleted_at IS NULL
        AND (p.project_id = $1 OR $1 = '')
        AND pe.endpoint_id = ANY($2::text[])
        AND p.id >= $3
    GROUP BY p.id
    ORDER BY p.id ASC
    LIMIT $4
)
SELECT id, project_id, name, token, endpoints, auth_type, can_manage_endpoint, owner_id, endpoint_count, created_at, updated_at, endpoints_metadata FROM portal_links ORDER BY id DESC
`

type FetchPortalLinksPaginatedBackwardWithEndpointFilterParams struct {
	ProjectID   string
	EndpointIds []string
	Cursor      string
	LimitVal    int64
}

type FetchPortalLinksPaginatedBackwardWithEndpointFilterRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinksPaginatedBackwardWithEndpointFilter(ctx context.Context, arg FetchPortalLinksPaginatedBackwardWithEndpointFilterParams) ([]FetchPortalLinksPaginatedBackwardWithEndpointFilterRow, error) {
	rows, err := q.db.Query(ctx, fetchPortalLinksPaginatedBackwardWithEndpointFilter,
		arg.ProjectID,
		arg.EndpointIds,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPortalLinksPaginatedBackwardWithEndpointFilterRow
	for rows.Next() {
		var i FetchPortalLinksPaginatedBackwardWithEndpointFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Token,
			&i.Endpoints,
			&i.AuthType,
			&i.CanManageEndpoint,
			&i.OwnerID,
			&i.EndpointCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointsMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPortalLinksPaginatedForward = `-- name: FetchPortalLinksPaginatedForward :many

SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.deleted_at IS NULL
    AND (p.project_id = $1 OR $1 = '')
    AND p.id <= $2
GROUP BY p.id
ORDER BY p.id DESC
LIMIT $3
`

type FetchPortalLinksPaginatedForwardParams struct {
	ProjectID string
	Cursor    string
	LimitVal  int64
}

type FetchPortalLinksPaginatedForwardRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

// Paginated queries
// Note: These queries are complex and may need dynamic construction in the application layer
// The following are base queries that can be used with dynamic filtering
func (q *Queries) FetchPortalLinksPaginatedForward(ctx context.Context, arg FetchPortalLinksPaginatedForwardParams) ([]FetchPortalLinksPaginatedForwardRow, error) {
	rows, err := q.db.Query(ctx, fetchPortalLinksPaginatedForward, arg.ProjectID, arg.Cursor, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPortalLinksPaginatedForwardRow
	for rows.Next() {
		var i FetchPortalLinksPaginatedForwardRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Token,
			&i.Endpoints,
			&i.AuthType,
			&i.CanManageEndpoint,
			&i.OwnerID,
			&i.EndpointCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointsMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPortalLinksPaginatedForwardWithEndpointFilter = `-- name: FetchPortalLinksPaginatedForwardWithEndpointFilter :many
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.deleted_at IS NULL
    AND (p.project_id = $1 OR $1 = '')
    AND pe.endpoint_id = ANY($2::text[])
    AND p.id <= $3
GROUP BY p.id
ORDER BY p.id DESC
LIMIT $4
`

type FetchPortalLinksPaginatedForwardWithEndpointFilterParams struct {
	ProjectID   string
	EndpointIds []string
	Cursor      string
	LimitVal    int64
}

type FetchPortalLinksPaginatedForwardWithEndpointFilterRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinksPaginatedForwardWithEndpointFilter(ctx context.Context, arg FetchPortalLinksPaginatedForwardWithEndpointFilterParams) ([]FetchPortalLinksPaginatedForwardWithEndpointFilterRow, error) {
	rows, err := q.db.Query(ctx, fetchPortalLinksPaginatedForwardWithEndpointFilter,
		arg.ProjectID,
		arg.EndpointIds,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPortalLinksPaginatedForwardWithEndpointFilterRow
	for rows.Next() {
		var i FetchPortalLinksPaginatedForwardWithEndpointFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Token,
			&i.Endpoints,
			&i.AuthType,
			&i.CanManageEndpoint,
			&i.OwnerID,
			&i.EndpointCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointsMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEndpointOwnerID = `-- name: UpdateEndpointOwnerID :exec
UPDATE convoy.endpoints
SET owner_id = $1
WHERE id = $2 AND project_id = $3 AND deleted_at IS NULL
`

type UpdateEndpointOwnerIDParams struct {
	OwnerID   pgtype.Text
	ID        string
	ProjectID string
}

func (q *Queries) UpdateEndpointOwnerID(ctx context.Context, arg UpdateEndpointOwnerIDParams) error {
	_, err := q.db.Exec(ctx, updateEndpointOwnerID, arg.OwnerID, arg.ID, arg.ProjectID)
	return err
}

const updatePortalLink = `-- name: UpdatePortalLink :exec
UPDATE convoy.portal_links
SET
    endpoints = $1,
    owner_id = $2,
    can_manage_endpoint = $3,
    name = $4,
    auth_type = $5,
    updated_at = NOW()
WHERE id = $6 AND project_id = $7 AND deleted_at IS NULL
`

type UpdatePortalLinkParams struct {
	Endpoints         pgtype.Text
	OwnerID           pgtype.Text
	CanManageEndpoint pgtype.Bool
	Name              string
	AuthType          ConvoyPortalAuthTypes
	ID                string
	ProjectID         string
}

func (q *Queries) UpdatePortalLink(ctx context.Context, arg UpdatePortalLinkParams) error {
	_, err := q.db.Exec(ctx, updatePortalLink,
		arg.Endpoints,
		arg.OwnerID,
		arg.CanManageEndpoint,
		arg.Name,
		arg.AuthType,
		arg.ID,
		arg.ProjectID,
	)
	return err
}
