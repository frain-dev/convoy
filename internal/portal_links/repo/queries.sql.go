// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const bulkWritePortalAuthTokens = `-- name: BulkWritePortalAuthTokens :exec
INSERT INTO convoy.portal_tokens (id, portal_link_id, token_mask_id, token_hash, token_salt, token_expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type BulkWritePortalAuthTokensParams struct {
	ID             string
	PortalLinkID   string
	TokenMaskID    pgtype.Text
	TokenHash      pgtype.Text
	TokenSalt      pgtype.Text
	TokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) BulkWritePortalAuthTokens(ctx context.Context, arg BulkWritePortalAuthTokensParams) error {
	_, err := q.db.Exec(ctx, bulkWritePortalAuthTokens,
		arg.ID,
		arg.PortalLinkID,
		arg.TokenMaskID,
		arg.TokenHash,
		arg.TokenSalt,
		arg.TokenExpiresAt,
	)
	return err
}

const countPrevPortalLinks = `-- name: CountPrevPortalLinks :one
SELECT COALESCE(COUNT(DISTINCT p.id), 0) AS count
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.deleted_at IS NULL
    AND (p.project_id = $1 OR $1 = '')
    AND p.id > $2
    -- Optional endpoint filter: apply only if has_endpoint_filter is true
    AND (
        CASE
            WHEN $3::boolean THEN pe.endpoint_id = ANY($4::text[])
            ELSE true
        END
    )
`

type CountPrevPortalLinksParams struct {
	ProjectID         string
	Cursor            string
	HasEndpointFilter bool
	EndpointIds       []string
}

// Unified count query for pagination prev row count
func (q *Queries) CountPrevPortalLinks(ctx context.Context, arg CountPrevPortalLinksParams) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, countPrevPortalLinks,
		arg.ProjectID,
		arg.Cursor,
		arg.HasEndpointFilter,
		arg.EndpointIds,
	)
	var count pgtype.Int8
	err := row.Scan(&count)
	return count, err
}

const createPortalLink = `-- name: CreatePortalLink :exec

INSERT INTO convoy.portal_links (id, project_id, name, token, endpoints, owner_id, can_manage_endpoint, auth_type)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreatePortalLinkParams struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	OwnerID           pgtype.Text
	CanManageEndpoint pgtype.Bool
	AuthType          ConvoyPortalAuthTypes
}

// Portal Links Queries
func (q *Queries) CreatePortalLink(ctx context.Context, arg CreatePortalLinkParams) error {
	_, err := q.db.Exec(ctx, createPortalLink,
		arg.ID,
		arg.ProjectID,
		arg.Name,
		arg.Token,
		arg.Endpoints,
		arg.OwnerID,
		arg.CanManageEndpoint,
		arg.AuthType,
	)
	return err
}

const createPortalLinkAuthToken = `-- name: CreatePortalLinkAuthToken :exec
INSERT INTO convoy.portal_tokens (id, portal_link_id, token_mask_id, token_hash, token_salt, token_expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreatePortalLinkAuthTokenParams struct {
	ID             string
	PortalLinkID   string
	TokenMaskID    pgtype.Text
	TokenHash      pgtype.Text
	TokenSalt      pgtype.Text
	TokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) CreatePortalLinkAuthToken(ctx context.Context, arg CreatePortalLinkAuthTokenParams) error {
	_, err := q.db.Exec(ctx, createPortalLinkAuthToken,
		arg.ID,
		arg.PortalLinkID,
		arg.TokenMaskID,
		arg.TokenHash,
		arg.TokenSalt,
		arg.TokenExpiresAt,
	)
	return err
}

const createPortalLinkEndpoint = `-- name: CreatePortalLinkEndpoint :exec
INSERT INTO convoy.portal_links_endpoints (portal_link_id, endpoint_id)
VALUES ($1, $2)
`

type CreatePortalLinkEndpointParams struct {
	PortalLinkID string
	EndpointID   string
}

func (q *Queries) CreatePortalLinkEndpoint(ctx context.Context, arg CreatePortalLinkEndpointParams) error {
	_, err := q.db.Exec(ctx, createPortalLinkEndpoint, arg.PortalLinkID, arg.EndpointID)
	return err
}

const deletePortalLink = `-- name: DeletePortalLink :exec
UPDATE convoy.portal_links
SET deleted_at = NOW()
WHERE id = $1 AND project_id = $2 AND deleted_at IS NULL
`

type DeletePortalLinkParams struct {
	ID        string
	ProjectID string
}

func (q *Queries) DeletePortalLink(ctx context.Context, arg DeletePortalLinkParams) error {
	_, err := q.db.Exec(ctx, deletePortalLink, arg.ID, arg.ProjectID)
	return err
}

const deletePortalLinkEndpoints = `-- name: DeletePortalLinkEndpoints :exec
DELETE FROM convoy.portal_links_endpoints
WHERE portal_link_id = $1 OR endpoint_id = $2
`

type DeletePortalLinkEndpointsParams struct {
	PortalLinkID string
	EndpointID   string
}

func (q *Queries) DeletePortalLinkEndpoints(ctx context.Context, arg DeletePortalLinkEndpointsParams) error {
	_, err := q.db.Exec(ctx, deletePortalLinkEndpoints, arg.PortalLinkID, arg.EndpointID)
	return err
}

const fetchPortalLinkById = `-- name: FetchPortalLinkById :one
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.id = $1 AND p.project_id = $2 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinkByIdParams struct {
	ID        string
	ProjectID string
}

type FetchPortalLinkByIdRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinkById(ctx context.Context, arg FetchPortalLinkByIdParams) (FetchPortalLinkByIdRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkById, arg.ID, arg.ProjectID)
	var i FetchPortalLinkByIdRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndpointsMetadata,
	)
	return i, err
}

const fetchPortalLinkByMaskId = `-- name: FetchPortalLinkByMaskId :one
SELECT
    pl.id,
    pl.project_id,
    pt.token_salt,
    pt.token_mask_id,
    pt.token_expires_at,
    pt.token_hash,
    pl.name,
    pl.token,
    pl.endpoints,
    pl.auth_type,
    COALESCE(pl.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(pl.owner_id, '') AS owner_id,
    CASE
        WHEN pl.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = pl.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = pl.id)
    END AS endpoint_count
FROM convoy.portal_tokens pt
JOIN convoy.portal_links pl ON pl.id = pt.portal_link_id
WHERE pt.token_mask_id = $1
`

type FetchPortalLinkByMaskIdRow struct {
	ID                string
	ProjectID         string
	TokenSalt         pgtype.Text
	TokenMaskID       pgtype.Text
	TokenExpiresAt    pgtype.Timestamptz
	TokenHash         pgtype.Text
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
}

func (q *Queries) FetchPortalLinkByMaskId(ctx context.Context, tokenMaskID pgtype.Text) (FetchPortalLinkByMaskIdRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkByMaskId, tokenMaskID)
	var i FetchPortalLinkByMaskIdRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.TokenSalt,
		&i.TokenMaskID,
		&i.TokenExpiresAt,
		&i.TokenHash,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
	)
	return i, err
}

const fetchPortalLinkByOwnerID = `-- name: FetchPortalLinkByOwnerID :one
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.owner_id = $1 AND p.project_id = $2 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinkByOwnerIDParams struct {
	OwnerID   pgtype.Text
	ProjectID string
}

type FetchPortalLinkByOwnerIDRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinkByOwnerID(ctx context.Context, arg FetchPortalLinkByOwnerIDParams) (FetchPortalLinkByOwnerIDRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkByOwnerID, arg.OwnerID, arg.ProjectID)
	var i FetchPortalLinkByOwnerIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndpointsMetadata,
	)
	return i, err
}

const fetchPortalLinkByToken = `-- name: FetchPortalLinkByToken :one
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.token = $1 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinkByTokenRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinkByToken(ctx context.Context, token string) (FetchPortalLinkByTokenRow, error) {
	row := q.db.QueryRow(ctx, fetchPortalLinkByToken, token)
	var i FetchPortalLinkByTokenRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Token,
		&i.Endpoints,
		&i.AuthType,
		&i.CanManageEndpoint,
		&i.OwnerID,
		&i.EndpointCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EndpointsMetadata,
	)
	return i, err
}

const fetchPortalLinksByOwnerID = `-- name: FetchPortalLinksByOwnerID :many
SELECT
    p.id,
    p.project_id,
    p.name,
    p.token,
    p.endpoints,
    p.auth_type,
    COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
    COALESCE(p.owner_id, '') AS owner_id,
    CASE
        WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
        ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
    END AS endpoint_count,
    p.created_at,
    p.updated_at,
    ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
        CASE WHEN e.id IS NOT NULL THEN
            cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
        END
    )) AS endpoints_metadata
FROM convoy.portal_links p
LEFT JOIN convoy.portal_links_endpoints pe
    ON p.id = pe.portal_link_id
LEFT JOIN convoy.endpoints e
    ON e.id = pe.endpoint_id
WHERE p.owner_id = $1 AND p.deleted_at IS NULL
GROUP BY p.id
`

type FetchPortalLinksByOwnerIDRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

func (q *Queries) FetchPortalLinksByOwnerID(ctx context.Context, ownerID pgtype.Text) ([]FetchPortalLinksByOwnerIDRow, error) {
	rows, err := q.db.Query(ctx, fetchPortalLinksByOwnerID, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPortalLinksByOwnerIDRow
	for rows.Next() {
		var i FetchPortalLinksByOwnerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Token,
			&i.Endpoints,
			&i.AuthType,
			&i.CanManageEndpoint,
			&i.OwnerID,
			&i.EndpointCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointsMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchPortalLinksPaginated = `-- name: FetchPortalLinksPaginated :many

WITH filtered_portal_links AS (
    SELECT
        p.id,
        p.project_id,
        p.name,
        p.token,
        p.endpoints,
        p.auth_type,
        COALESCE(p.can_manage_endpoint, FALSE) AS can_manage_endpoint,
        COALESCE(p.owner_id, '') AS owner_id,
        CASE
            WHEN p.owner_id != '' THEN (SELECT count(id) FROM convoy.endpoints WHERE owner_id = p.owner_id)
            ELSE (SELECT count(portal_link_id) FROM convoy.portal_links_endpoints WHERE portal_link_id = p.id)
        END AS endpoint_count,
        p.created_at,
        p.updated_at,
        ARRAY_TO_JSON(ARRAY_AGG(DISTINCT
            CASE WHEN e.id IS NOT NULL THEN
                cast(JSON_BUILD_OBJECT('uid', e.id, 'name', e.name, 'project_id', e.project_id, 'url', e.url, 'secrets', e.secrets) as jsonb)
            END
        )) AS endpoints_metadata
    FROM convoy.portal_links p
    LEFT JOIN convoy.portal_links_endpoints pe
        ON p.id = pe.portal_link_id
    LEFT JOIN convoy.endpoints e
        ON e.id = pe.endpoint_id
    WHERE p.deleted_at IS NULL
        AND (p.project_id = $2 OR $2 = '')
        -- Cursor comparison: <= for forward (next), >= for backward (prev)
        AND (
            CASE
                WHEN $1::text = 'next' THEN p.id <= $3
                WHEN $1::text = 'prev' THEN p.id >= $3
                ELSE true
            END
        )
        -- Optional endpoint filter: apply only if has_endpoint_filter is true
        AND (
            CASE
                WHEN $4::boolean THEN pe.endpoint_id = ANY($5::text[])
                ELSE true
            END
        )
    GROUP BY p.id
    -- Sort order: DESC for forward, ASC for backward (will be reversed in outer query for backward)
    ORDER BY
        CASE
            WHEN $1::text = 'next' THEN p.id
        END DESC,
        CASE
            WHEN $1::text = 'prev' THEN p.id
        END ASC
    LIMIT $6
)
SELECT id, project_id, name, token, endpoints, auth_type, can_manage_endpoint, owner_id, endpoint_count, created_at, updated_at, endpoints_metadata FROM filtered_portal_links
ORDER BY
    CASE
        WHEN $1::text = 'prev' THEN id
    END DESC,
    CASE
        WHEN $1::text = 'next' THEN id
    END DESC
`

type FetchPortalLinksPaginatedParams struct {
	Direction         string
	ProjectID         string
	Cursor            string
	HasEndpointFilter bool
	EndpointIds       []string
	LimitVal          int64
}

type FetchPortalLinksPaginatedRow struct {
	ID                string
	ProjectID         string
	Name              string
	Token             string
	Endpoints         pgtype.Text
	AuthType          ConvoyPortalAuthTypes
	CanManageEndpoint bool
	OwnerID           string
	EndpointCount     pgtype.Int8
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	EndpointsMetadata []byte
}

// Unified Paginated queries using CASE and COALESCE for dynamic filtering
// These queries handle both forward/backward pagination and optional endpoint filtering
// @direction: 'next' for forward pagination, 'prev' for backward pagination
// @has_endpoint_filter: true to filter by endpoint_ids, false to skip filtering
// Final select: reverse order for backward pagination to get DESC order
func (q *Queries) FetchPortalLinksPaginated(ctx context.Context, arg FetchPortalLinksPaginatedParams) ([]FetchPortalLinksPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchPortalLinksPaginated,
		arg.Direction,
		arg.ProjectID,
		arg.Cursor,
		arg.HasEndpointFilter,
		arg.EndpointIds,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPortalLinksPaginatedRow
	for rows.Next() {
		var i FetchPortalLinksPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Token,
			&i.Endpoints,
			&i.AuthType,
			&i.CanManageEndpoint,
			&i.OwnerID,
			&i.EndpointCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EndpointsMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEndpointOwnerID = `-- name: UpdateEndpointOwnerID :exec
UPDATE convoy.endpoints
SET owner_id = $1
WHERE id = $2 AND project_id = $3 AND deleted_at IS NULL
`

type UpdateEndpointOwnerIDParams struct {
	OwnerID   pgtype.Text
	ID        string
	ProjectID string
}

func (q *Queries) UpdateEndpointOwnerID(ctx context.Context, arg UpdateEndpointOwnerIDParams) error {
	_, err := q.db.Exec(ctx, updateEndpointOwnerID, arg.OwnerID, arg.ID, arg.ProjectID)
	return err
}

const updatePortalLink = `-- name: UpdatePortalLink :exec
UPDATE convoy.portal_links
SET
    endpoints = $1,
    owner_id = $2,
    can_manage_endpoint = $3,
    name = $4,
    auth_type = $5,
    updated_at = NOW()
WHERE id = $6 AND project_id = $7 AND deleted_at IS NULL
`

type UpdatePortalLinkParams struct {
	Endpoints         pgtype.Text
	OwnerID           pgtype.Text
	CanManageEndpoint pgtype.Bool
	Name              string
	AuthType          ConvoyPortalAuthTypes
	ID                string
	ProjectID         string
}

func (q *Queries) UpdatePortalLink(ctx context.Context, arg UpdatePortalLinkParams) error {
	_, err := q.db.Exec(ctx, updatePortalLink,
		arg.Endpoints,
		arg.OwnerID,
		arg.CanManageEndpoint,
		arg.Name,
		arg.AuthType,
		arg.ID,
		arg.ProjectID,
	)
	return err
}
