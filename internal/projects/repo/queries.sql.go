// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProjects = `-- name: CountProjects :one
SELECT COUNT(*) FROM convoy.projects WHERE deleted_at IS NULL
`

func (q *Queries) CountProjects(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProjects)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProject = `-- name: CreateProject :exec

INSERT INTO convoy.projects (id, name, type, logo_url, organisation_id, project_configuration_id)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateProjectParams struct {
	ID                     string
	Name                   string
	Type                   string
	LogoUrl                pgtype.Text
	OrganisationID         string
	ProjectConfigurationID string
}

// Project CRUD Queries
func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) error {
	_, err := q.db.Exec(ctx, createProject,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.LogoUrl,
		arg.OrganisationID,
		arg.ProjectConfigurationID,
	)
	return err
}

const createProjectConfiguration = `-- name: CreateProjectConfiguration :exec

INSERT INTO convoy.project_configurations (
    id, search_policy, max_payload_read_size,
    replay_attacks_prevention_enabled, ratelimit_count,
    ratelimit_duration, strategy_type, strategy_duration,
    strategy_retry_count, signature_header, signature_versions,
    disable_endpoint, meta_events_enabled, meta_events_type,
    meta_events_event_type, meta_events_url, meta_events_secret,
    meta_events_pub_sub, ssl_enforce_secure_endpoints,
    cb_sample_rate, cb_error_timeout, cb_failure_threshold,
    cb_success_threshold, cb_observability_window,
    cb_minimum_request_count, cb_consecutive_failure_threshold
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,
    $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26
)
`

type CreateProjectConfigurationParams struct {
	ID                             string
	SearchPolicy                   pgtype.Text
	MaxPayloadReadSize             int32
	ReplayAttacksPreventionEnabled bool
	RatelimitCount                 int32
	RatelimitDuration              int32
	StrategyType                   string
	StrategyDuration               int32
	StrategyRetryCount             int32
	SignatureHeader                string
	SignatureVersions              []byte
	DisableEndpoint                bool
	MetaEventsEnabled              bool
	MetaEventsType                 pgtype.Text
	MetaEventsEventType            pgtype.Text
	MetaEventsUrl                  pgtype.Text
	MetaEventsSecret               pgtype.Text
	MetaEventsPubSub               []byte
	SslEnforceSecureEndpoints      pgtype.Bool
	CbSampleRate                   int32
	CbErrorTimeout                 int32
	CbFailureThreshold             int32
	CbSuccessThreshold             int32
	CbObservabilityWindow          int32
	CbMinimumRequestCount          int32
	CbConsecutiveFailureThreshold  int32
}

// Project Configuration Queries
func (q *Queries) CreateProjectConfiguration(ctx context.Context, arg CreateProjectConfigurationParams) error {
	_, err := q.db.Exec(ctx, createProjectConfiguration,
		arg.ID,
		arg.SearchPolicy,
		arg.MaxPayloadReadSize,
		arg.ReplayAttacksPreventionEnabled,
		arg.RatelimitCount,
		arg.RatelimitDuration,
		arg.StrategyType,
		arg.StrategyDuration,
		arg.StrategyRetryCount,
		arg.SignatureHeader,
		arg.SignatureVersions,
		arg.DisableEndpoint,
		arg.MetaEventsEnabled,
		arg.MetaEventsType,
		arg.MetaEventsEventType,
		arg.MetaEventsUrl,
		arg.MetaEventsSecret,
		arg.MetaEventsPubSub,
		arg.SslEnforceSecureEndpoints,
		arg.CbSampleRate,
		arg.CbErrorTimeout,
		arg.CbFailureThreshold,
		arg.CbSuccessThreshold,
		arg.CbObservabilityWindow,
		arg.CbMinimumRequestCount,
		arg.CbConsecutiveFailureThreshold,
	)
	return err
}

const deleteProject = `-- name: DeleteProject :execresult
UPDATE convoy.projects SET
    deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteProject(ctx context.Context, id string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteProject, id)
}

const deleteProjectEndpoints = `-- name: DeleteProjectEndpoints :execresult

UPDATE convoy.endpoints SET
    deleted_at = NOW()
WHERE project_id = $1 AND deleted_at IS NULL
`

// Cascade Delete Queries
func (q *Queries) DeleteProjectEndpoints(ctx context.Context, projectID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteProjectEndpoints, projectID)
}

const deleteProjectEvents = `-- name: DeleteProjectEvents :execresult
UPDATE convoy.events
SET deleted_at = NOW()
WHERE project_id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteProjectEvents(ctx context.Context, projectID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteProjectEvents, projectID)
}

const deleteProjectSubscriptions = `-- name: DeleteProjectSubscriptions :execresult
UPDATE convoy.subscriptions SET
    deleted_at = NOW()
WHERE project_id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteProjectSubscriptions(ctx context.Context, projectID string) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteProjectSubscriptions, projectID)
}

const fetchProjectByID = `-- name: FetchProjectByID :one
SELECT
    p.id,
    p.name,
    p.type,
    p.retained_events,
    p.logo_url,
    p.organisation_id,
    p.project_configuration_id,
    c.search_policy AS "config_search_policy",
    c.max_payload_read_size AS "config_max_payload_read_size",
    c.multiple_endpoint_subscriptions AS "config_multiple_endpoint_subscriptions",
    c.replay_attacks_prevention_enabled AS "config_replay_attacks_prevention_enabled",
    c.ratelimit_count AS "config_ratelimit_count",
    c.ratelimit_duration AS "config_ratelimit_duration",
    c.strategy_type AS "config_strategy_type",
    c.strategy_duration AS "config_strategy_duration",
    c.strategy_retry_count AS "config_strategy_retry_count",
    c.signature_header AS "config_signature_header",
    c.signature_versions AS "config_signature_versions",
    c.disable_endpoint AS "config_disable_endpoint",
    c.ssl_enforce_secure_endpoints AS "config_ssl_enforce_secure_endpoints",
    c.meta_events_enabled AS "config_meta_events_enabled",
    COALESCE(c.meta_events_type, '') AS "config_meta_events_type",
    c.meta_events_event_type AS "config_meta_events_event_type",
    COALESCE(c.meta_events_url, '') AS "config_meta_events_url",
    COALESCE(c.meta_events_secret, '') AS "config_meta_events_secret",
    c.meta_events_pub_sub AS "config_meta_events_pub_sub",
    c.cb_sample_rate AS "config_cb_sample_rate",
    c.cb_error_timeout AS "config_cb_error_timeout",
    c.cb_failure_threshold AS "config_cb_failure_threshold",
    c.cb_success_threshold AS "config_cb_success_threshold",
    c.cb_observability_window AS "config_cb_observability_window",
    c.cb_minimum_request_count AS "config_cb_minimum_request_count",
    c.cb_consecutive_failure_threshold AS "config_cb_consecutive_failure_threshold",
    p.created_at,
    p.updated_at,
    p.deleted_at
FROM convoy.projects p
LEFT JOIN convoy.project_configurations c
ON p.project_configuration_id = c.id
WHERE p.id = $1 AND p.deleted_at IS NULL
`

type FetchProjectByIDRow struct {
	ID                                   string
	Name                                 string
	Type                                 string
	RetainedEvents                       pgtype.Int4
	LogoUrl                              pgtype.Text
	OrganisationID                       string
	ProjectConfigurationID               string
	ConfigSearchPolicy                   pgtype.Text
	ConfigMaxPayloadReadSize             pgtype.Int4
	ConfigMultipleEndpointSubscriptions  pgtype.Bool
	ConfigReplayAttacksPreventionEnabled pgtype.Bool
	ConfigRatelimitCount                 pgtype.Int4
	ConfigRatelimitDuration              pgtype.Int4
	ConfigStrategyType                   pgtype.Text
	ConfigStrategyDuration               pgtype.Int4
	ConfigStrategyRetryCount             pgtype.Int4
	ConfigSignatureHeader                pgtype.Text
	ConfigSignatureVersions              []byte
	ConfigDisableEndpoint                pgtype.Bool
	ConfigSslEnforceSecureEndpoints      pgtype.Bool
	ConfigMetaEventsEnabled              pgtype.Bool
	ConfigMetaEventsType                 string
	ConfigMetaEventsEventType            pgtype.Text
	ConfigMetaEventsUrl                  string
	ConfigMetaEventsSecret               string
	ConfigMetaEventsPubSub               []byte
	ConfigCbSampleRate                   pgtype.Int4
	ConfigCbErrorTimeout                 pgtype.Int4
	ConfigCbFailureThreshold             pgtype.Int4
	ConfigCbSuccessThreshold             pgtype.Int4
	ConfigCbObservabilityWindow          pgtype.Int4
	ConfigCbMinimumRequestCount          pgtype.Int4
	ConfigCbConsecutiveFailureThreshold  pgtype.Int4
	CreatedAt                            pgtype.Timestamptz
	UpdatedAt                            pgtype.Timestamptz
	DeletedAt                            pgtype.Timestamptz
}

func (q *Queries) FetchProjectByID(ctx context.Context, id string) (FetchProjectByIDRow, error) {
	row := q.db.QueryRow(ctx, fetchProjectByID, id)
	var i FetchProjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.RetainedEvents,
		&i.LogoUrl,
		&i.OrganisationID,
		&i.ProjectConfigurationID,
		&i.ConfigSearchPolicy,
		&i.ConfigMaxPayloadReadSize,
		&i.ConfigMultipleEndpointSubscriptions,
		&i.ConfigReplayAttacksPreventionEnabled,
		&i.ConfigRatelimitCount,
		&i.ConfigRatelimitDuration,
		&i.ConfigStrategyType,
		&i.ConfigStrategyDuration,
		&i.ConfigStrategyRetryCount,
		&i.ConfigSignatureHeader,
		&i.ConfigSignatureVersions,
		&i.ConfigDisableEndpoint,
		&i.ConfigSslEnforceSecureEndpoints,
		&i.ConfigMetaEventsEnabled,
		&i.ConfigMetaEventsType,
		&i.ConfigMetaEventsEventType,
		&i.ConfigMetaEventsUrl,
		&i.ConfigMetaEventsSecret,
		&i.ConfigMetaEventsPubSub,
		&i.ConfigCbSampleRate,
		&i.ConfigCbErrorTimeout,
		&i.ConfigCbFailureThreshold,
		&i.ConfigCbSuccessThreshold,
		&i.ConfigCbObservabilityWindow,
		&i.ConfigCbMinimumRequestCount,
		&i.ConfigCbConsecutiveFailureThreshold,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const fetchProjectStatistics = `-- name: FetchProjectStatistics :one

SELECT
    (SELECT EXISTS(SELECT 1 FROM convoy.subscriptions WHERE project_id = $1 AND deleted_at IS NULL)) AS subscriptions_exist,
    (SELECT EXISTS(SELECT 1 FROM convoy.endpoints WHERE project_id = $1 AND deleted_at IS NULL)) AS endpoints_exist,
    (SELECT EXISTS(SELECT 1 FROM convoy.sources WHERE project_id = $1 AND deleted_at IS NULL)) AS sources_exist,
    (SELECT EXISTS(SELECT 1 FROM convoy.events WHERE project_id = $1 AND deleted_at IS NULL)) AS events_exist
`

type FetchProjectStatisticsRow struct {
	SubscriptionsExist bool
	EndpointsExist     bool
	SourcesExist       bool
	EventsExist        bool
}

// Statistics Queries
func (q *Queries) FetchProjectStatistics(ctx context.Context, dollar_1 pgtype.Text) (FetchProjectStatisticsRow, error) {
	row := q.db.QueryRow(ctx, fetchProjectStatistics, dollar_1)
	var i FetchProjectStatisticsRow
	err := row.Scan(
		&i.SubscriptionsExist,
		&i.EndpointsExist,
		&i.SourcesExist,
		&i.EventsExist,
	)
	return i, err
}

const fetchProjects = `-- name: FetchProjects :many
SELECT
    p.id,
    p.name,
    p.type,
    p.retained_events,
    p.logo_url,
    p.organisation_id,
    p.project_configuration_id,
    c.search_policy AS "config_search_policy",
    c.max_payload_read_size AS "config_max_payload_read_size",
    c.multiple_endpoint_subscriptions AS "config_multiple_endpoint_subscriptions",
    c.replay_attacks_prevention_enabled AS "config_replay_attacks_prevention_enabled",
    c.ratelimit_count AS "config_ratelimit_count",
    c.ratelimit_duration AS "config_ratelimit_duration",
    c.strategy_type AS "config_strategy_type",
    c.strategy_duration AS "config_strategy_duration",
    c.strategy_retry_count AS "config_strategy_retry_count",
    c.signature_header AS "config_signature_header",
    c.signature_versions AS "config_signature_versions",
    c.disable_endpoint AS "config_disable_endpoint",
    c.ssl_enforce_secure_endpoints AS "config_ssl_enforce_secure_endpoints",
    c.meta_events_enabled AS "config_meta_events_enabled",
    COALESCE(c.meta_events_type, '') AS "config_meta_events_type",
    c.meta_events_event_type AS "config_meta_events_event_type",
    COALESCE(c.meta_events_url, '') AS "config_meta_events_url",
    COALESCE(c.meta_events_secret, '') AS "config_meta_events_secret",
    c.meta_events_pub_sub AS "config_meta_events_pub_sub",
    c.cb_sample_rate AS "config_cb_sample_rate",
    c.cb_error_timeout AS "config_cb_error_timeout",
    c.cb_failure_threshold AS "config_cb_failure_threshold",
    c.cb_success_threshold AS "config_cb_success_threshold",
    c.cb_observability_window AS "config_cb_observability_window",
    c.cb_minimum_request_count AS "config_cb_minimum_request_count",
    c.cb_consecutive_failure_threshold AS "config_cb_consecutive_failure_threshold",
    p.created_at,
    p.updated_at,
    p.deleted_at
FROM convoy.projects p
LEFT JOIN convoy.project_configurations c
ON p.project_configuration_id = c.id
WHERE (p.organisation_id = $1 OR $1 = '') AND p.deleted_at IS NULL
ORDER BY p.id
`

type FetchProjectsRow struct {
	ID                                   string
	Name                                 string
	Type                                 string
	RetainedEvents                       pgtype.Int4
	LogoUrl                              pgtype.Text
	OrganisationID                       string
	ProjectConfigurationID               string
	ConfigSearchPolicy                   pgtype.Text
	ConfigMaxPayloadReadSize             pgtype.Int4
	ConfigMultipleEndpointSubscriptions  pgtype.Bool
	ConfigReplayAttacksPreventionEnabled pgtype.Bool
	ConfigRatelimitCount                 pgtype.Int4
	ConfigRatelimitDuration              pgtype.Int4
	ConfigStrategyType                   pgtype.Text
	ConfigStrategyDuration               pgtype.Int4
	ConfigStrategyRetryCount             pgtype.Int4
	ConfigSignatureHeader                pgtype.Text
	ConfigSignatureVersions              []byte
	ConfigDisableEndpoint                pgtype.Bool
	ConfigSslEnforceSecureEndpoints      pgtype.Bool
	ConfigMetaEventsEnabled              pgtype.Bool
	ConfigMetaEventsType                 string
	ConfigMetaEventsEventType            pgtype.Text
	ConfigMetaEventsUrl                  string
	ConfigMetaEventsSecret               string
	ConfigMetaEventsPubSub               []byte
	ConfigCbSampleRate                   pgtype.Int4
	ConfigCbErrorTimeout                 pgtype.Int4
	ConfigCbFailureThreshold             pgtype.Int4
	ConfigCbSuccessThreshold             pgtype.Int4
	ConfigCbObservabilityWindow          pgtype.Int4
	ConfigCbMinimumRequestCount          pgtype.Int4
	ConfigCbConsecutiveFailureThreshold  pgtype.Int4
	CreatedAt                            pgtype.Timestamptz
	UpdatedAt                            pgtype.Timestamptz
	DeletedAt                            pgtype.Timestamptz
}

func (q *Queries) FetchProjects(ctx context.Context, orgID string) ([]FetchProjectsRow, error) {
	rows, err := q.db.Query(ctx, fetchProjects, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchProjectsRow
	for rows.Next() {
		var i FetchProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.RetainedEvents,
			&i.LogoUrl,
			&i.OrganisationID,
			&i.ProjectConfigurationID,
			&i.ConfigSearchPolicy,
			&i.ConfigMaxPayloadReadSize,
			&i.ConfigMultipleEndpointSubscriptions,
			&i.ConfigReplayAttacksPreventionEnabled,
			&i.ConfigRatelimitCount,
			&i.ConfigRatelimitDuration,
			&i.ConfigStrategyType,
			&i.ConfigStrategyDuration,
			&i.ConfigStrategyRetryCount,
			&i.ConfigSignatureHeader,
			&i.ConfigSignatureVersions,
			&i.ConfigDisableEndpoint,
			&i.ConfigSslEnforceSecureEndpoints,
			&i.ConfigMetaEventsEnabled,
			&i.ConfigMetaEventsType,
			&i.ConfigMetaEventsEventType,
			&i.ConfigMetaEventsUrl,
			&i.ConfigMetaEventsSecret,
			&i.ConfigMetaEventsPubSub,
			&i.ConfigCbSampleRate,
			&i.ConfigCbErrorTimeout,
			&i.ConfigCbFailureThreshold,
			&i.ConfigCbSuccessThreshold,
			&i.ConfigCbObservabilityWindow,
			&i.ConfigCbMinimumRequestCount,
			&i.ConfigCbConsecutiveFailureThreshold,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsWithEventsInInterval = `-- name: GetProjectsWithEventsInInterval :many
SELECT p.id, COUNT(e.id) AS events_count
FROM convoy.projects p
LEFT JOIN convoy.events e ON p.id = e.project_id
WHERE e.created_at >= NOW() - MAKE_INTERVAL(hours := $1)
    AND p.deleted_at IS NULL
GROUP BY p.id
ORDER BY events_count DESC
`

type GetProjectsWithEventsInIntervalRow struct {
	ID          string
	EventsCount int64
}

// Analytics Queries
func (q *Queries) GetProjectsWithEventsInInterval(ctx context.Context, hours int32) ([]GetProjectsWithEventsInIntervalRow, error) {
	rows, err := q.db.Query(ctx, getProjectsWithEventsInInterval, hours)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsWithEventsInIntervalRow
	for rows.Next() {
		var i GetProjectsWithEventsInIntervalRow
		if err := rows.Scan(&i.ID, &i.EventsCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :execresult
UPDATE convoy.projects SET
    name = $2,
    logo_url = $3,
    retained_events = $4,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateProjectParams struct {
	ID             string
	Name           string
	LogoUrl        pgtype.Text
	RetainedEvents pgtype.Int4
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateProject,
		arg.ID,
		arg.Name,
		arg.LogoUrl,
		arg.RetainedEvents,
	)
}

const updateProjectConfiguration = `-- name: UpdateProjectConfiguration :execresult
UPDATE convoy.project_configurations SET
    max_payload_read_size = $2,
    replay_attacks_prevention_enabled = $3,
    ratelimit_count = $4,
    ratelimit_duration = $5,
    strategy_type = $6,
    strategy_duration = $7,
    strategy_retry_count = $8,
    signature_header = $9,
    signature_versions = $10,
    disable_endpoint = $11,
    meta_events_enabled = $12,
    meta_events_type = $13,
    meta_events_event_type = $14,
    meta_events_url = $15,
    meta_events_secret = $16,
    meta_events_pub_sub = $17,
    search_policy = $18,
    ssl_enforce_secure_endpoints = $19,
    cb_sample_rate = $20,
    cb_error_timeout = $21,
    cb_failure_threshold = $22,
    cb_success_threshold = $23,
    cb_observability_window = $24,
    cb_minimum_request_count = $25,
    cb_consecutive_failure_threshold = $26,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateProjectConfigurationParams struct {
	ID                             string
	MaxPayloadReadSize             int32
	ReplayAttacksPreventionEnabled bool
	RatelimitCount                 int32
	RatelimitDuration              int32
	StrategyType                   string
	StrategyDuration               int32
	StrategyRetryCount             int32
	SignatureHeader                string
	SignatureVersions              []byte
	DisableEndpoint                bool
	MetaEventsEnabled              bool
	MetaEventsType                 pgtype.Text
	MetaEventsEventType            pgtype.Text
	MetaEventsUrl                  pgtype.Text
	MetaEventsSecret               pgtype.Text
	MetaEventsPubSub               []byte
	SearchPolicy                   pgtype.Text
	SslEnforceSecureEndpoints      pgtype.Bool
	CbSampleRate                   int32
	CbErrorTimeout                 int32
	CbFailureThreshold             int32
	CbSuccessThreshold             int32
	CbObservabilityWindow          int32
	CbMinimumRequestCount          int32
	CbConsecutiveFailureThreshold  int32
}

func (q *Queries) UpdateProjectConfiguration(ctx context.Context, arg UpdateProjectConfigurationParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateProjectConfiguration,
		arg.ID,
		arg.MaxPayloadReadSize,
		arg.ReplayAttacksPreventionEnabled,
		arg.RatelimitCount,
		arg.RatelimitDuration,
		arg.StrategyType,
		arg.StrategyDuration,
		arg.StrategyRetryCount,
		arg.SignatureHeader,
		arg.SignatureVersions,
		arg.DisableEndpoint,
		arg.MetaEventsEnabled,
		arg.MetaEventsType,
		arg.MetaEventsEventType,
		arg.MetaEventsUrl,
		arg.MetaEventsSecret,
		arg.MetaEventsPubSub,
		arg.SearchPolicy,
		arg.SslEnforceSecureEndpoints,
		arg.CbSampleRate,
		arg.CbErrorTimeout,
		arg.CbFailureThreshold,
		arg.CbSuccessThreshold,
		arg.CbObservabilityWindow,
		arg.CbMinimumRequestCount,
		arg.CbConsecutiveFailureThreshold,
	)
}

const updateProjectEndpointStatus = `-- name: UpdateProjectEndpointStatus :many

UPDATE convoy.endpoints
SET status = $1, updated_at = NOW()
WHERE project_id = $2
    AND status = ANY($3::text[])
    AND deleted_at IS NULL
RETURNING
    id, name, status, owner_id, url,
    description, http_timeout, rate_limit, rate_limit_duration,
    advanced_signatures, slack_webhook_url, support_email,
    app_id, project_id, secrets, created_at, updated_at,
    authentication_type AS "authentication_type",
    authentication_type_api_key_header_name AS "authentication_api_key_header_name",
    authentication_type_api_key_header_value AS "authentication_api_key_header_value"
`

type UpdateProjectEndpointStatusParams struct {
	Status    string
	ProjectID string
	Column3   []string
}

type UpdateProjectEndpointStatusRow struct {
	ID                              string
	Name                            string
	Status                          string
	OwnerID                         pgtype.Text
	Url                             string
	Description                     pgtype.Text
	HttpTimeout                     int32
	RateLimit                       int32
	RateLimitDuration               int32
	AdvancedSignatures              bool
	SlackWebhookUrl                 pgtype.Text
	SupportEmail                    pgtype.Text
	AppID                           pgtype.Text
	ProjectID                       string
	Secrets                         []byte
	CreatedAt                       pgtype.Timestamptz
	UpdatedAt                       pgtype.Timestamptz
	AuthenticationType              pgtype.Text
	AuthenticationApiKeyHeaderName  pgtype.Text
	AuthenticationApiKeyHeaderValue pgtype.Text
}

// Endpoint Update Query
func (q *Queries) UpdateProjectEndpointStatus(ctx context.Context, arg UpdateProjectEndpointStatusParams) ([]UpdateProjectEndpointStatusRow, error) {
	rows, err := q.db.Query(ctx, updateProjectEndpointStatus, arg.Status, arg.ProjectID, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpdateProjectEndpointStatusRow
	for rows.Next() {
		var i UpdateProjectEndpointStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.OwnerID,
			&i.Url,
			&i.Description,
			&i.HttpTimeout,
			&i.RateLimit,
			&i.RateLimitDuration,
			&i.AdvancedSignatures,
			&i.SlackWebhookUrl,
			&i.SupportEmail,
			&i.AppID,
			&i.ProjectID,
			&i.Secrets,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthenticationType,
			&i.AuthenticationApiKeyHeaderName,
			&i.AuthenticationApiKeyHeaderValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
