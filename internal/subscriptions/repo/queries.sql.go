// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const countEndpointSubscriptions = `-- name: CountEndpointSubscriptions :one

SELECT COUNT(s.id) AS count
FROM convoy.subscriptions s
WHERE s.deleted_at IS NULL
    AND s.project_id = $1
    AND s.endpoint_id = $2
    AND s.id <> $3
`

type CountEndpointSubscriptionsParams struct {
	ProjectID             string
	EndpointID            pgtype.Text
	ExcludeSubscriptionID string
}

// ============================================================================
// UTILITY Operations
// ============================================================================
// Count subscriptions for a specific endpoint (excluding a specific subscription)
func (q *Queries) CountEndpointSubscriptions(ctx context.Context, arg CountEndpointSubscriptionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEndpointSubscriptions, arg.ProjectID, arg.EndpointID, arg.ExcludeSubscriptionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPrevSubscriptions = `-- name: CountPrevSubscriptions :one
SELECT COUNT(DISTINCT s.id) AS count
FROM convoy.subscriptions s
WHERE s.deleted_at IS NULL
    AND s.project_id = $1
    AND s.id > $2
    -- Optional endpoint filter
    AND (
        CASE
            WHEN $3::boolean THEN s.endpoint_id = ANY($4::text[])
            ELSE true
        END
    )
    -- Optional name search filter
    AND (
        CASE
            WHEN $5::boolean THEN s.name ILIKE $6
            ELSE true
        END
    )
`

type CountPrevSubscriptionsParams struct {
	ProjectID         string
	Cursor            string
	HasEndpointFilter bool
	EndpointIds       []string
	HasNameFilter     bool
	NameFilter        string
}

// Unified count query for pagination prev row count
func (q *Queries) CountPrevSubscriptions(ctx context.Context, arg CountPrevSubscriptionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPrevSubscriptions,
		arg.ProjectID,
		arg.Cursor,
		arg.HasEndpointFilter,
		arg.EndpointIds,
		arg.HasNameFilter,
		arg.NameFilter,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectSubscriptions = `-- name: CountProjectSubscriptions :one
SELECT COUNT(s.id) AS count
FROM convoy.subscriptions s
WHERE s.deleted_at IS NULL
    AND s.project_id = ANY($1::text[])
`

// Count all subscriptions across multiple projects
func (q *Queries) CountProjectSubscriptions(ctx context.Context, projectIds []string) (int64, error) {
	row := q.db.QueryRow(ctx, countProjectSubscriptions, projectIds)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubscription = `-- name: CreateSubscription :exec


INSERT INTO convoy.subscriptions (
    id,
    name,
    type,
    project_id,
    endpoint_id,
    device_id,
    source_id,
    alert_config_count,
    alert_config_threshold,
    retry_config_type,
    retry_config_duration,
    retry_config_retry_count,
    filter_config_event_types,
    filter_config_filter_headers,
    filter_config_filter_body,
    filter_config_filter_is_flattened,
    filter_config_filter_raw_headers,
    filter_config_filter_raw_body,
    rate_limit_config_count,
    rate_limit_config_duration,
    function,
    delivery_mode
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15,
    $16,
    $17,
    $18,
    $19,
    $20,
    $21,
    CASE
        WHEN $22 = '' OR $22 IS NULL THEN 'at_least_once'::convoy.delivery_mode
        ELSE $22::convoy.delivery_mode
    END
)
`

type CreateSubscriptionParams struct {
	ID                            string
	Name                          string
	Type                          string
	ProjectID                     string
	EndpointID                    pgtype.Text
	DeviceID                      pgtype.Text
	SourceID                      pgtype.Text
	AlertConfigCount              int32
	AlertConfigThreshold          string
	RetryConfigType               string
	RetryConfigDuration           int32
	RetryConfigRetryCount         int32
	FilterConfigEventTypes        []string
	FilterConfigFilterHeaders     []byte
	FilterConfigFilterBody        []byte
	FilterConfigFilterIsFlattened pgtype.Bool
	FilterConfigFilterRawHeaders  []byte
	FilterConfigFilterRawBody     []byte
	RateLimitConfigCount          int32
	RateLimitConfigDuration       int32
	Function                      pgtype.Text
	DeliveryMode                  pgtype.Text
}

// Subscriptions Queries
// ============================================================================
// CREATE Operations
// ============================================================================
func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, createSubscription,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.ProjectID,
		arg.EndpointID,
		arg.DeviceID,
		arg.SourceID,
		arg.AlertConfigCount,
		arg.AlertConfigThreshold,
		arg.RetryConfigType,
		arg.RetryConfigDuration,
		arg.RetryConfigRetryCount,
		arg.FilterConfigEventTypes,
		arg.FilterConfigFilterHeaders,
		arg.FilterConfigFilterBody,
		arg.FilterConfigFilterIsFlattened,
		arg.FilterConfigFilterRawHeaders,
		arg.FilterConfigFilterRawBody,
		arg.RateLimitConfigCount,
		arg.RateLimitConfigDuration,
		arg.Function,
		arg.DeliveryMode,
	)
	return err
}

const deleteSubscription = `-- name: DeleteSubscription :execresult

UPDATE convoy.subscriptions
SET deleted_at = NOW()
WHERE id = $1 AND project_id = $2 AND deleted_at IS NULL
`

type DeleteSubscriptionParams struct {
	ID        string
	ProjectID string
}

// ============================================================================
// DELETE Operations
// ============================================================================
func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteSubscription, arg.ID, arg.ProjectID)
}

const deleteSubscriptionEventTypes = `-- name: DeleteSubscriptionEventTypes :exec
DELETE FROM convoy.filters
WHERE id IN (
    SELECT f.id AS filter_id
    FROM convoy.filters f
    JOIN convoy.subscriptions s ON s.id = f.subscription_id
    WHERE s.id = $1
        AND f.event_type <> ALL(s.filter_config_event_types)
)
`

func (q *Queries) DeleteSubscriptionEventTypes(ctx context.Context, subscriptionID string) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionEventTypes, subscriptionID)
	return err
}

const fetchCLISubscriptions = `-- name: FetchCLISubscriptions :many
SELECT
    s.id,
    s.name,
    s.type,
    s.project_id,
    s.created_at,
    s.updated_at,
    s.function,
    s.delivery_mode,
    COALESCE(s.endpoint_id, '') AS endpoint_id,
    COALESCE(s.device_id, '') AS device_id,
    COALESCE(s.source_id, '') AS source_id,
    s.alert_config_count,
    s.alert_config_threshold,
    s.retry_config_type,
    s.retry_config_duration,
    s.retry_config_retry_count,
    s.filter_config_event_types,
    s.filter_config_filter_raw_headers,
    s.filter_config_filter_raw_body,
    s.filter_config_filter_is_flattened,
    s.filter_config_filter_headers,
    s.filter_config_filter_body,
    s.rate_limit_config_count,
    s.rate_limit_config_duration,
    COALESCE(em.id, '') AS endpoint_metadata_id,
    COALESCE(em.name, '') AS endpoint_metadata_name,
    COALESCE(em.project_id, '') AS endpoint_metadata_project_id,
    COALESCE(em.support_email, '') AS endpoint_metadata_support_email,
    COALESCE(em.url, '') AS endpoint_metadata_url,
    COALESCE(em.status, '') AS endpoint_metadata_status,
    COALESCE(em.owner_id, '') AS endpoint_metadata_owner_id,
    COALESCE(em.secrets, '[]'::jsonb) AS endpoint_metadata_secrets,
    COALESCE(d.id, '') AS device_metadata_id,
    COALESCE(d.status, '') AS device_metadata_status,
    COALESCE(d.host_name, '') AS device_metadata_host_name,
    COALESCE(sm.id, '') AS source_metadata_id,
    COALESCE(sm.name, '') AS source_metadata_name,
    COALESCE(sm.type, '') AS source_metadata_type,
    COALESCE(sm.mask_id, '') AS source_metadata_mask_id,
    COALESCE(sm.project_id, '') AS source_metadata_project_id,
    COALESCE(sm.is_disabled, FALSE) AS source_metadata_is_disabled,
    COALESCE(sv.type, '') AS source_verifier_type,
    COALESCE(sv.basic_username, '') AS source_verifier_basic_username,
    COALESCE(sv.basic_password, '') AS source_verifier_basic_password,
    COALESCE(sv.api_key_header_name, '') AS source_verifier_api_key_header_name,
    COALESCE(sv.api_key_header_value, '') AS source_verifier_api_key_header_value,
    COALESCE(sv.hmac_hash, '') AS source_verifier_hmac_hash,
    COALESCE(sv.hmac_header, '') AS source_verifier_hmac_header,
    COALESCE(sv.hmac_secret, '') AS source_verifier_hmac_secret,
    COALESCE(sv.hmac_encoding, '') AS source_verifier_hmac_encoding
FROM convoy.subscriptions s
LEFT JOIN convoy.endpoints em ON s.endpoint_id = em.id
LEFT JOIN convoy.sources sm ON s.source_id = sm.id
LEFT JOIN convoy.source_verifiers sv ON sv.id = sm.source_verifier_id
LEFT JOIN convoy.devices d ON s.device_id = d.id
WHERE s.project_id = $1 AND s.type = 'cli' AND s.deleted_at IS NULL
`

type FetchCLISubscriptionsRow struct {
	ID                              string
	Name                            string
	Type                            string
	ProjectID                       string
	CreatedAt                       pgtype.Timestamptz
	UpdatedAt                       pgtype.Timestamptz
	Function                        pgtype.Text
	DeliveryMode                    NullConvoyDeliveryMode
	EndpointID                      string
	DeviceID                        string
	SourceID                        string
	AlertConfigCount                int32
	AlertConfigThreshold            string
	RetryConfigType                 string
	RetryConfigDuration             int32
	RetryConfigRetryCount           int32
	FilterConfigEventTypes          []string
	FilterConfigFilterRawHeaders    []byte
	FilterConfigFilterRawBody       []byte
	FilterConfigFilterIsFlattened   pgtype.Bool
	FilterConfigFilterHeaders       []byte
	FilterConfigFilterBody          []byte
	RateLimitConfigCount            int32
	RateLimitConfigDuration         int32
	EndpointMetadataID              string
	EndpointMetadataName            string
	EndpointMetadataProjectID       string
	EndpointMetadataSupportEmail    string
	EndpointMetadataUrl             string
	EndpointMetadataStatus          string
	EndpointMetadataOwnerID         string
	EndpointMetadataSecrets         []byte
	DeviceMetadataID                string
	DeviceMetadataStatus            string
	DeviceMetadataHostName          string
	SourceMetadataID                string
	SourceMetadataName              string
	SourceMetadataType              string
	SourceMetadataMaskID            string
	SourceMetadataProjectID         string
	SourceMetadataIsDisabled        bool
	SourceVerifierType              string
	SourceVerifierBasicUsername     string
	SourceVerifierBasicPassword     string
	SourceVerifierApiKeyHeaderName  string
	SourceVerifierApiKeyHeaderValue string
	SourceVerifierHmacHash          string
	SourceVerifierHmacHeader        string
	SourceVerifierHmacSecret        string
	SourceVerifierHmacEncoding      string
}

func (q *Queries) FetchCLISubscriptions(ctx context.Context, projectID string) ([]FetchCLISubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, fetchCLISubscriptions, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchCLISubscriptionsRow
	for rows.Next() {
		var i FetchCLISubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Function,
			&i.DeliveryMode,
			&i.EndpointID,
			&i.DeviceID,
			&i.SourceID,
			&i.AlertConfigCount,
			&i.AlertConfigThreshold,
			&i.RetryConfigType,
			&i.RetryConfigDuration,
			&i.RetryConfigRetryCount,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterRawHeaders,
			&i.FilterConfigFilterRawBody,
			&i.FilterConfigFilterIsFlattened,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.RateLimitConfigCount,
			&i.RateLimitConfigDuration,
			&i.EndpointMetadataID,
			&i.EndpointMetadataName,
			&i.EndpointMetadataProjectID,
			&i.EndpointMetadataSupportEmail,
			&i.EndpointMetadataUrl,
			&i.EndpointMetadataStatus,
			&i.EndpointMetadataOwnerID,
			&i.EndpointMetadataSecrets,
			&i.DeviceMetadataID,
			&i.DeviceMetadataStatus,
			&i.DeviceMetadataHostName,
			&i.SourceMetadataID,
			&i.SourceMetadataName,
			&i.SourceMetadataType,
			&i.SourceMetadataMaskID,
			&i.SourceMetadataProjectID,
			&i.SourceMetadataIsDisabled,
			&i.SourceVerifierType,
			&i.SourceVerifierBasicUsername,
			&i.SourceVerifierBasicPassword,
			&i.SourceVerifierApiKeyHeaderName,
			&i.SourceVerifierApiKeyHeaderValue,
			&i.SourceVerifierHmacHash,
			&i.SourceVerifierHmacHeader,
			&i.SourceVerifierHmacSecret,
			&i.SourceVerifierHmacEncoding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchDeletedSubscriptions = `-- name: FetchDeletedSubscriptions :many
SELECT
    id,
    deleted_at,
    project_id,
    filter_config_event_types
FROM convoy.subscriptions
WHERE deleted_at IS NOT NULL
    AND id = ANY($1::text[])
    AND project_id = ANY($2::text[])
ORDER BY id
LIMIT $3
`

type FetchDeletedSubscriptionsParams struct {
	SubscriptionIds []string
	ProjectIds      []string
	LimitVal        int64
}

type FetchDeletedSubscriptionsRow struct {
	ID                     string
	DeletedAt              pgtype.Timestamptz
	ProjectID              string
	FilterConfigEventTypes []string
}

// Fetch subscriptions that have been deleted
func (q *Queries) FetchDeletedSubscriptions(ctx context.Context, arg FetchDeletedSubscriptionsParams) ([]FetchDeletedSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, fetchDeletedSubscriptions, arg.SubscriptionIds, arg.ProjectIds, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchDeletedSubscriptionsRow
	for rows.Next() {
		var i FetchDeletedSubscriptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.DeletedAt,
			&i.ProjectID,
			&i.FilterConfigEventTypes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchNewSubscriptions = `-- name: FetchNewSubscriptions :many
SELECT
    s.name,
    s.id,
    s.type,
    s.project_id,
    s.endpoint_id,
    s.function,
    s.updated_at,
    s.filter_config_event_types,
    s.filter_config_filter_headers,
    s.filter_config_filter_body,
    s.filter_config_filter_is_flattened,
    s.filter_config_filter_raw_headers,
    s.filter_config_filter_raw_body
FROM convoy.subscriptions s
WHERE s.created_at > $1
    AND ($2::boolean = false OR s.id <> ALL($3::text[]))
    AND s.project_id = ANY($4::text[])
    AND s.deleted_at IS NULL
ORDER BY s.id
LIMIT $5
`

type FetchNewSubscriptionsParams struct {
	LastSyncTime         pgtype.Timestamptz
	HasKnownIds          bool
	KnownSubscriptionIds []string
	ProjectIds           []string
	LimitVal             int64
}

type FetchNewSubscriptionsRow struct {
	Name                          string
	ID                            string
	Type                          string
	ProjectID                     string
	EndpointID                    pgtype.Text
	Function                      pgtype.Text
	UpdatedAt                     pgtype.Timestamptz
	FilterConfigEventTypes        []string
	FilterConfigFilterHeaders     []byte
	FilterConfigFilterBody        []byte
	FilterConfigFilterIsFlattened pgtype.Bool
	FilterConfigFilterRawHeaders  []byte
	FilterConfigFilterRawBody     []byte
}

// Fetch new subscriptions created after last sync time
func (q *Queries) FetchNewSubscriptions(ctx context.Context, arg FetchNewSubscriptionsParams) ([]FetchNewSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, fetchNewSubscriptions,
		arg.LastSyncTime,
		arg.HasKnownIds,
		arg.KnownSubscriptionIds,
		arg.ProjectIds,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchNewSubscriptionsRow
	for rows.Next() {
		var i FetchNewSubscriptionsRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.Type,
			&i.ProjectID,
			&i.EndpointID,
			&i.Function,
			&i.UpdatedAt,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.FilterConfigFilterIsFlattened,
			&i.FilterConfigFilterRawHeaders,
			&i.FilterConfigFilterRawBody,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSubscriptionByDeviceID = `-- name: FetchSubscriptionByDeviceID :one
SELECT
    s.id,
    s.name,
    s.type,
    s.project_id,
    s.created_at,
    s.updated_at,
    s.function,
    s.delivery_mode,
    COALESCE(s.endpoint_id, '') AS endpoint_id,
    COALESCE(s.device_id, '') AS device_id,
    COALESCE(s.source_id, '') AS source_id,
    s.alert_config_count,
    s.alert_config_threshold,
    s.retry_config_type,
    s.retry_config_duration,
    s.retry_config_retry_count,
    s.filter_config_event_types,
    s.filter_config_filter_raw_headers,
    s.filter_config_filter_raw_body,
    s.filter_config_filter_is_flattened,
    s.filter_config_filter_headers,
    s.filter_config_filter_body,
    s.rate_limit_config_count,
    s.rate_limit_config_duration,
    COALESCE(d.id, '') AS device_metadata_id,
    COALESCE(d.status, '') AS device_metadata_status,
    COALESCE(d.host_name, '') AS device_metadata_host_name
FROM convoy.subscriptions s
LEFT JOIN convoy.devices d ON s.device_id = d.id
WHERE s.device_id = $1 AND s.project_id = $2 AND s.type = $3 AND s.deleted_at IS NULL
`

type FetchSubscriptionByDeviceIDParams struct {
	DeviceID         pgtype.Text
	ProjectID        string
	SubscriptionType string
}

type FetchSubscriptionByDeviceIDRow struct {
	ID                            string
	Name                          string
	Type                          string
	ProjectID                     string
	CreatedAt                     pgtype.Timestamptz
	UpdatedAt                     pgtype.Timestamptz
	Function                      pgtype.Text
	DeliveryMode                  NullConvoyDeliveryMode
	EndpointID                    string
	DeviceID                      string
	SourceID                      string
	AlertConfigCount              int32
	AlertConfigThreshold          string
	RetryConfigType               string
	RetryConfigDuration           int32
	RetryConfigRetryCount         int32
	FilterConfigEventTypes        []string
	FilterConfigFilterRawHeaders  []byte
	FilterConfigFilterRawBody     []byte
	FilterConfigFilterIsFlattened pgtype.Bool
	FilterConfigFilterHeaders     []byte
	FilterConfigFilterBody        []byte
	RateLimitConfigCount          int32
	RateLimitConfigDuration       int32
	DeviceMetadataID              string
	DeviceMetadataStatus          string
	DeviceMetadataHostName        string
}

func (q *Queries) FetchSubscriptionByDeviceID(ctx context.Context, arg FetchSubscriptionByDeviceIDParams) (FetchSubscriptionByDeviceIDRow, error) {
	row := q.db.QueryRow(ctx, fetchSubscriptionByDeviceID, arg.DeviceID, arg.ProjectID, arg.SubscriptionType)
	var i FetchSubscriptionByDeviceIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Function,
		&i.DeliveryMode,
		&i.EndpointID,
		&i.DeviceID,
		&i.SourceID,
		&i.AlertConfigCount,
		&i.AlertConfigThreshold,
		&i.RetryConfigType,
		&i.RetryConfigDuration,
		&i.RetryConfigRetryCount,
		&i.FilterConfigEventTypes,
		&i.FilterConfigFilterRawHeaders,
		&i.FilterConfigFilterRawBody,
		&i.FilterConfigFilterIsFlattened,
		&i.FilterConfigFilterHeaders,
		&i.FilterConfigFilterBody,
		&i.RateLimitConfigCount,
		&i.RateLimitConfigDuration,
		&i.DeviceMetadataID,
		&i.DeviceMetadataStatus,
		&i.DeviceMetadataHostName,
	)
	return i, err
}

const fetchSubscriptionByID = `-- name: FetchSubscriptionByID :one

SELECT
    s.id,
    s.name,
    s.type,
    s.project_id,
    s.created_at,
    s.updated_at,
    s.function,
    s.delivery_mode,
    COALESCE(s.endpoint_id, '') AS endpoint_id,
    COALESCE(s.device_id, '') AS device_id,
    COALESCE(s.source_id, '') AS source_id,
    s.alert_config_count,
    s.alert_config_threshold,
    s.retry_config_type,
    s.retry_config_duration,
    s.retry_config_retry_count,
    s.filter_config_event_types,
    s.filter_config_filter_raw_headers,
    s.filter_config_filter_raw_body,
    s.filter_config_filter_is_flattened,
    s.filter_config_filter_headers,
    s.filter_config_filter_body,
    s.rate_limit_config_count,
    s.rate_limit_config_duration,
    COALESCE(em.id, '') AS endpoint_metadata_id,
    COALESCE(em.name, '') AS endpoint_metadata_name,
    COALESCE(em.project_id, '') AS endpoint_metadata_project_id,
    COALESCE(em.support_email, '') AS endpoint_metadata_support_email,
    COALESCE(em.url, '') AS endpoint_metadata_url,
    COALESCE(em.status, '') AS endpoint_metadata_status,
    COALESCE(em.owner_id, '') AS endpoint_metadata_owner_id,
    COALESCE(em.secrets, '[]'::jsonb) AS endpoint_metadata_secrets,
    COALESCE(d.id, '') AS device_metadata_id,
    COALESCE(d.status, '') AS device_metadata_status,
    COALESCE(d.host_name, '') AS device_metadata_host_name,
    COALESCE(sm.id, '') AS source_metadata_id,
    COALESCE(sm.name, '') AS source_metadata_name,
    COALESCE(sm.type, '') AS source_metadata_type,
    COALESCE(sm.mask_id, '') AS source_metadata_mask_id,
    COALESCE(sm.project_id, '') AS source_metadata_project_id,
    COALESCE(sm.is_disabled, FALSE) AS source_metadata_is_disabled,
    COALESCE(sv.type, '') AS source_verifier_type,
    COALESCE(sv.basic_username, '') AS source_verifier_basic_username,
    COALESCE(sv.basic_password, '') AS source_verifier_basic_password,
    COALESCE(sv.api_key_header_name, '') AS source_verifier_api_key_header_name,
    COALESCE(sv.api_key_header_value, '') AS source_verifier_api_key_header_value,
    COALESCE(sv.hmac_hash, '') AS source_verifier_hmac_hash,
    COALESCE(sv.hmac_header, '') AS source_verifier_hmac_header,
    COALESCE(sv.hmac_secret, '') AS source_verifier_hmac_secret,
    COALESCE(sv.hmac_encoding, '') AS source_verifier_hmac_encoding
FROM convoy.subscriptions s
LEFT JOIN convoy.endpoints em ON s.endpoint_id = em.id
LEFT JOIN convoy.sources sm ON s.source_id = sm.id
LEFT JOIN convoy.source_verifiers sv ON sv.id = sm.source_verifier_id
LEFT JOIN convoy.devices d ON s.device_id = d.id
WHERE s.id = $1 AND s.project_id = $2 AND s.deleted_at IS NULL
`

type FetchSubscriptionByIDParams struct {
	ID        string
	ProjectID string
}

type FetchSubscriptionByIDRow struct {
	ID                              string
	Name                            string
	Type                            string
	ProjectID                       string
	CreatedAt                       pgtype.Timestamptz
	UpdatedAt                       pgtype.Timestamptz
	Function                        pgtype.Text
	DeliveryMode                    NullConvoyDeliveryMode
	EndpointID                      string
	DeviceID                        string
	SourceID                        string
	AlertConfigCount                int32
	AlertConfigThreshold            string
	RetryConfigType                 string
	RetryConfigDuration             int32
	RetryConfigRetryCount           int32
	FilterConfigEventTypes          []string
	FilterConfigFilterRawHeaders    []byte
	FilterConfigFilterRawBody       []byte
	FilterConfigFilterIsFlattened   pgtype.Bool
	FilterConfigFilterHeaders       []byte
	FilterConfigFilterBody          []byte
	RateLimitConfigCount            int32
	RateLimitConfigDuration         int32
	EndpointMetadataID              string
	EndpointMetadataName            string
	EndpointMetadataProjectID       string
	EndpointMetadataSupportEmail    string
	EndpointMetadataUrl             string
	EndpointMetadataStatus          string
	EndpointMetadataOwnerID         string
	EndpointMetadataSecrets         []byte
	DeviceMetadataID                string
	DeviceMetadataStatus            string
	DeviceMetadataHostName          string
	SourceMetadataID                string
	SourceMetadataName              string
	SourceMetadataType              string
	SourceMetadataMaskID            string
	SourceMetadataProjectID         string
	SourceMetadataIsDisabled        bool
	SourceVerifierType              string
	SourceVerifierBasicUsername     string
	SourceVerifierBasicPassword     string
	SourceVerifierApiKeyHeaderName  string
	SourceVerifierApiKeyHeaderValue string
	SourceVerifierHmacHash          string
	SourceVerifierHmacHeader        string
	SourceVerifierHmacSecret        string
	SourceVerifierHmacEncoding      string
}

// ============================================================================
// FETCH Operations
// ============================================================================
func (q *Queries) FetchSubscriptionByID(ctx context.Context, arg FetchSubscriptionByIDParams) (FetchSubscriptionByIDRow, error) {
	row := q.db.QueryRow(ctx, fetchSubscriptionByID, arg.ID, arg.ProjectID)
	var i FetchSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Function,
		&i.DeliveryMode,
		&i.EndpointID,
		&i.DeviceID,
		&i.SourceID,
		&i.AlertConfigCount,
		&i.AlertConfigThreshold,
		&i.RetryConfigType,
		&i.RetryConfigDuration,
		&i.RetryConfigRetryCount,
		&i.FilterConfigEventTypes,
		&i.FilterConfigFilterRawHeaders,
		&i.FilterConfigFilterRawBody,
		&i.FilterConfigFilterIsFlattened,
		&i.FilterConfigFilterHeaders,
		&i.FilterConfigFilterBody,
		&i.RateLimitConfigCount,
		&i.RateLimitConfigDuration,
		&i.EndpointMetadataID,
		&i.EndpointMetadataName,
		&i.EndpointMetadataProjectID,
		&i.EndpointMetadataSupportEmail,
		&i.EndpointMetadataUrl,
		&i.EndpointMetadataStatus,
		&i.EndpointMetadataOwnerID,
		&i.EndpointMetadataSecrets,
		&i.DeviceMetadataID,
		&i.DeviceMetadataStatus,
		&i.DeviceMetadataHostName,
		&i.SourceMetadataID,
		&i.SourceMetadataName,
		&i.SourceMetadataType,
		&i.SourceMetadataMaskID,
		&i.SourceMetadataProjectID,
		&i.SourceMetadataIsDisabled,
		&i.SourceVerifierType,
		&i.SourceVerifierBasicUsername,
		&i.SourceVerifierBasicPassword,
		&i.SourceVerifierApiKeyHeaderName,
		&i.SourceVerifierApiKeyHeaderValue,
		&i.SourceVerifierHmacHash,
		&i.SourceVerifierHmacHeader,
		&i.SourceVerifierHmacSecret,
		&i.SourceVerifierHmacEncoding,
	)
	return i, err
}

const fetchSubscriptionsByEndpointID = `-- name: FetchSubscriptionsByEndpointID :many
SELECT
    s.id,
    s.name,
    s.type,
    s.project_id,
    s.created_at,
    s.updated_at,
    s.function,
    s.delivery_mode,
    COALESCE(s.endpoint_id, '') AS endpoint_id,
    COALESCE(s.device_id, '') AS device_id,
    COALESCE(s.source_id, '') AS source_id,
    s.alert_config_count,
    s.alert_config_threshold,
    s.retry_config_type,
    s.retry_config_duration,
    s.retry_config_retry_count,
    s.filter_config_event_types,
    s.filter_config_filter_raw_headers,
    s.filter_config_filter_raw_body,
    s.filter_config_filter_is_flattened,
    s.filter_config_filter_headers,
    s.filter_config_filter_body,
    s.rate_limit_config_count,
    s.rate_limit_config_duration,
    COALESCE(em.id, '') AS endpoint_metadata_id,
    COALESCE(em.name, '') AS endpoint_metadata_name,
    COALESCE(em.project_id, '') AS endpoint_metadata_project_id,
    COALESCE(em.support_email, '') AS endpoint_metadata_support_email,
    COALESCE(em.url, '') AS endpoint_metadata_url,
    COALESCE(em.status, '') AS endpoint_metadata_status,
    COALESCE(em.owner_id, '') AS endpoint_metadata_owner_id,
    COALESCE(em.secrets, '[]'::jsonb) AS endpoint_metadata_secrets,
    COALESCE(d.id, '') AS device_metadata_id,
    COALESCE(d.status, '') AS device_metadata_status,
    COALESCE(d.host_name, '') AS device_metadata_host_name,
    COALESCE(sm.id, '') AS source_metadata_id,
    COALESCE(sm.name, '') AS source_metadata_name,
    COALESCE(sm.type, '') AS source_metadata_type,
    COALESCE(sm.mask_id, '') AS source_metadata_mask_id,
    COALESCE(sm.project_id, '') AS source_metadata_project_id,
    COALESCE(sm.is_disabled, FALSE) AS source_metadata_is_disabled,
    COALESCE(sv.type, '') AS source_verifier_type,
    COALESCE(sv.basic_username, '') AS source_verifier_basic_username,
    COALESCE(sv.basic_password, '') AS source_verifier_basic_password,
    COALESCE(sv.api_key_header_name, '') AS source_verifier_api_key_header_name,
    COALESCE(sv.api_key_header_value, '') AS source_verifier_api_key_header_value,
    COALESCE(sv.hmac_hash, '') AS source_verifier_hmac_hash,
    COALESCE(sv.hmac_header, '') AS source_verifier_hmac_header,
    COALESCE(sv.hmac_secret, '') AS source_verifier_hmac_secret,
    COALESCE(sv.hmac_encoding, '') AS source_verifier_hmac_encoding
FROM convoy.subscriptions s
LEFT JOIN convoy.endpoints em ON s.endpoint_id = em.id
LEFT JOIN convoy.sources sm ON s.source_id = sm.id
LEFT JOIN convoy.source_verifiers sv ON sv.id = sm.source_verifier_id
LEFT JOIN convoy.devices d ON s.device_id = d.id
WHERE s.project_id = $1 AND s.endpoint_id = $2 AND s.deleted_at IS NULL
`

type FetchSubscriptionsByEndpointIDParams struct {
	ProjectID  string
	EndpointID pgtype.Text
}

type FetchSubscriptionsByEndpointIDRow struct {
	ID                              string
	Name                            string
	Type                            string
	ProjectID                       string
	CreatedAt                       pgtype.Timestamptz
	UpdatedAt                       pgtype.Timestamptz
	Function                        pgtype.Text
	DeliveryMode                    NullConvoyDeliveryMode
	EndpointID                      string
	DeviceID                        string
	SourceID                        string
	AlertConfigCount                int32
	AlertConfigThreshold            string
	RetryConfigType                 string
	RetryConfigDuration             int32
	RetryConfigRetryCount           int32
	FilterConfigEventTypes          []string
	FilterConfigFilterRawHeaders    []byte
	FilterConfigFilterRawBody       []byte
	FilterConfigFilterIsFlattened   pgtype.Bool
	FilterConfigFilterHeaders       []byte
	FilterConfigFilterBody          []byte
	RateLimitConfigCount            int32
	RateLimitConfigDuration         int32
	EndpointMetadataID              string
	EndpointMetadataName            string
	EndpointMetadataProjectID       string
	EndpointMetadataSupportEmail    string
	EndpointMetadataUrl             string
	EndpointMetadataStatus          string
	EndpointMetadataOwnerID         string
	EndpointMetadataSecrets         []byte
	DeviceMetadataID                string
	DeviceMetadataStatus            string
	DeviceMetadataHostName          string
	SourceMetadataID                string
	SourceMetadataName              string
	SourceMetadataType              string
	SourceMetadataMaskID            string
	SourceMetadataProjectID         string
	SourceMetadataIsDisabled        bool
	SourceVerifierType              string
	SourceVerifierBasicUsername     string
	SourceVerifierBasicPassword     string
	SourceVerifierApiKeyHeaderName  string
	SourceVerifierApiKeyHeaderValue string
	SourceVerifierHmacHash          string
	SourceVerifierHmacHeader        string
	SourceVerifierHmacSecret        string
	SourceVerifierHmacEncoding      string
}

func (q *Queries) FetchSubscriptionsByEndpointID(ctx context.Context, arg FetchSubscriptionsByEndpointIDParams) ([]FetchSubscriptionsByEndpointIDRow, error) {
	rows, err := q.db.Query(ctx, fetchSubscriptionsByEndpointID, arg.ProjectID, arg.EndpointID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchSubscriptionsByEndpointIDRow
	for rows.Next() {
		var i FetchSubscriptionsByEndpointIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Function,
			&i.DeliveryMode,
			&i.EndpointID,
			&i.DeviceID,
			&i.SourceID,
			&i.AlertConfigCount,
			&i.AlertConfigThreshold,
			&i.RetryConfigType,
			&i.RetryConfigDuration,
			&i.RetryConfigRetryCount,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterRawHeaders,
			&i.FilterConfigFilterRawBody,
			&i.FilterConfigFilterIsFlattened,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.RateLimitConfigCount,
			&i.RateLimitConfigDuration,
			&i.EndpointMetadataID,
			&i.EndpointMetadataName,
			&i.EndpointMetadataProjectID,
			&i.EndpointMetadataSupportEmail,
			&i.EndpointMetadataUrl,
			&i.EndpointMetadataStatus,
			&i.EndpointMetadataOwnerID,
			&i.EndpointMetadataSecrets,
			&i.DeviceMetadataID,
			&i.DeviceMetadataStatus,
			&i.DeviceMetadataHostName,
			&i.SourceMetadataID,
			&i.SourceMetadataName,
			&i.SourceMetadataType,
			&i.SourceMetadataMaskID,
			&i.SourceMetadataProjectID,
			&i.SourceMetadataIsDisabled,
			&i.SourceVerifierType,
			&i.SourceVerifierBasicUsername,
			&i.SourceVerifierBasicPassword,
			&i.SourceVerifierApiKeyHeaderName,
			&i.SourceVerifierApiKeyHeaderValue,
			&i.SourceVerifierHmacHash,
			&i.SourceVerifierHmacHeader,
			&i.SourceVerifierHmacSecret,
			&i.SourceVerifierHmacEncoding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSubscriptionsBySourceID = `-- name: FetchSubscriptionsBySourceID :many
SELECT
    s.id,
    s.name,
    s.type,
    s.project_id,
    s.created_at,
    s.updated_at,
    s.function,
    s.delivery_mode,
    COALESCE(s.endpoint_id, '') AS endpoint_id,
    COALESCE(s.device_id, '') AS device_id,
    COALESCE(s.source_id, '') AS source_id,
    s.alert_config_count,
    s.alert_config_threshold,
    s.retry_config_type,
    s.retry_config_duration,
    s.retry_config_retry_count,
    s.filter_config_event_types,
    s.filter_config_filter_raw_headers,
    s.filter_config_filter_raw_body,
    s.filter_config_filter_is_flattened,
    s.filter_config_filter_headers,
    s.filter_config_filter_body,
    s.rate_limit_config_count,
    s.rate_limit_config_duration,
    COALESCE(em.id, '') AS endpoint_metadata_id,
    COALESCE(em.name, '') AS endpoint_metadata_name,
    COALESCE(em.project_id, '') AS endpoint_metadata_project_id,
    COALESCE(em.support_email, '') AS endpoint_metadata_support_email,
    COALESCE(em.url, '') AS endpoint_metadata_url,
    COALESCE(em.status, '') AS endpoint_metadata_status,
    COALESCE(em.owner_id, '') AS endpoint_metadata_owner_id,
    COALESCE(em.secrets, '[]'::jsonb) AS endpoint_metadata_secrets,
    COALESCE(d.id, '') AS device_metadata_id,
    COALESCE(d.status, '') AS device_metadata_status,
    COALESCE(d.host_name, '') AS device_metadata_host_name,
    COALESCE(sm.id, '') AS source_metadata_id,
    COALESCE(sm.name, '') AS source_metadata_name,
    COALESCE(sm.type, '') AS source_metadata_type,
    COALESCE(sm.mask_id, '') AS source_metadata_mask_id,
    COALESCE(sm.project_id, '') AS source_metadata_project_id,
    COALESCE(sm.is_disabled, FALSE) AS source_metadata_is_disabled,
    COALESCE(sv.type, '') AS source_verifier_type,
    COALESCE(sv.basic_username, '') AS source_verifier_basic_username,
    COALESCE(sv.basic_password, '') AS source_verifier_basic_password,
    COALESCE(sv.api_key_header_name, '') AS source_verifier_api_key_header_name,
    COALESCE(sv.api_key_header_value, '') AS source_verifier_api_key_header_value,
    COALESCE(sv.hmac_hash, '') AS source_verifier_hmac_hash,
    COALESCE(sv.hmac_header, '') AS source_verifier_hmac_header,
    COALESCE(sv.hmac_secret, '') AS source_verifier_hmac_secret,
    COALESCE(sv.hmac_encoding, '') AS source_verifier_hmac_encoding
FROM convoy.subscriptions s
LEFT JOIN convoy.endpoints em ON s.endpoint_id = em.id
LEFT JOIN convoy.sources sm ON s.source_id = sm.id
LEFT JOIN convoy.source_verifiers sv ON sv.id = sm.source_verifier_id
LEFT JOIN convoy.devices d ON s.device_id = d.id
WHERE s.project_id = $1 AND s.source_id = $2 AND s.deleted_at IS NULL
`

type FetchSubscriptionsBySourceIDParams struct {
	ProjectID string
	SourceID  pgtype.Text
}

type FetchSubscriptionsBySourceIDRow struct {
	ID                              string
	Name                            string
	Type                            string
	ProjectID                       string
	CreatedAt                       pgtype.Timestamptz
	UpdatedAt                       pgtype.Timestamptz
	Function                        pgtype.Text
	DeliveryMode                    NullConvoyDeliveryMode
	EndpointID                      string
	DeviceID                        string
	SourceID                        string
	AlertConfigCount                int32
	AlertConfigThreshold            string
	RetryConfigType                 string
	RetryConfigDuration             int32
	RetryConfigRetryCount           int32
	FilterConfigEventTypes          []string
	FilterConfigFilterRawHeaders    []byte
	FilterConfigFilterRawBody       []byte
	FilterConfigFilterIsFlattened   pgtype.Bool
	FilterConfigFilterHeaders       []byte
	FilterConfigFilterBody          []byte
	RateLimitConfigCount            int32
	RateLimitConfigDuration         int32
	EndpointMetadataID              string
	EndpointMetadataName            string
	EndpointMetadataProjectID       string
	EndpointMetadataSupportEmail    string
	EndpointMetadataUrl             string
	EndpointMetadataStatus          string
	EndpointMetadataOwnerID         string
	EndpointMetadataSecrets         []byte
	DeviceMetadataID                string
	DeviceMetadataStatus            string
	DeviceMetadataHostName          string
	SourceMetadataID                string
	SourceMetadataName              string
	SourceMetadataType              string
	SourceMetadataMaskID            string
	SourceMetadataProjectID         string
	SourceMetadataIsDisabled        bool
	SourceVerifierType              string
	SourceVerifierBasicUsername     string
	SourceVerifierBasicPassword     string
	SourceVerifierApiKeyHeaderName  string
	SourceVerifierApiKeyHeaderValue string
	SourceVerifierHmacHash          string
	SourceVerifierHmacHeader        string
	SourceVerifierHmacSecret        string
	SourceVerifierHmacEncoding      string
}

func (q *Queries) FetchSubscriptionsBySourceID(ctx context.Context, arg FetchSubscriptionsBySourceIDParams) ([]FetchSubscriptionsBySourceIDRow, error) {
	rows, err := q.db.Query(ctx, fetchSubscriptionsBySourceID, arg.ProjectID, arg.SourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchSubscriptionsBySourceIDRow
	for rows.Next() {
		var i FetchSubscriptionsBySourceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Function,
			&i.DeliveryMode,
			&i.EndpointID,
			&i.DeviceID,
			&i.SourceID,
			&i.AlertConfigCount,
			&i.AlertConfigThreshold,
			&i.RetryConfigType,
			&i.RetryConfigDuration,
			&i.RetryConfigRetryCount,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterRawHeaders,
			&i.FilterConfigFilterRawBody,
			&i.FilterConfigFilterIsFlattened,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.RateLimitConfigCount,
			&i.RateLimitConfigDuration,
			&i.EndpointMetadataID,
			&i.EndpointMetadataName,
			&i.EndpointMetadataProjectID,
			&i.EndpointMetadataSupportEmail,
			&i.EndpointMetadataUrl,
			&i.EndpointMetadataStatus,
			&i.EndpointMetadataOwnerID,
			&i.EndpointMetadataSecrets,
			&i.DeviceMetadataID,
			&i.DeviceMetadataStatus,
			&i.DeviceMetadataHostName,
			&i.SourceMetadataID,
			&i.SourceMetadataName,
			&i.SourceMetadataType,
			&i.SourceMetadataMaskID,
			&i.SourceMetadataProjectID,
			&i.SourceMetadataIsDisabled,
			&i.SourceVerifierType,
			&i.SourceVerifierBasicUsername,
			&i.SourceVerifierBasicPassword,
			&i.SourceVerifierApiKeyHeaderName,
			&i.SourceVerifierApiKeyHeaderValue,
			&i.SourceVerifierHmacHash,
			&i.SourceVerifierHmacHeader,
			&i.SourceVerifierHmacSecret,
			&i.SourceVerifierHmacEncoding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSubscriptionsForBroadcast = `-- name: FetchSubscriptionsForBroadcast :many

SELECT
    id,
    type,
    project_id,
    endpoint_id,
    function,
    filter_config_event_types,
    filter_config_filter_headers,
    filter_config_filter_body,
    filter_config_filter_is_flattened
FROM convoy.subscriptions
WHERE (ARRAY[$1] <@ filter_config_event_types OR ARRAY['*'] <@ filter_config_event_types)
    AND id > $2
    AND project_id = $3
    AND deleted_at IS NULL
ORDER BY id
LIMIT $4
`

type FetchSubscriptionsForBroadcastParams struct {
	EventType string
	Cursor    string
	ProjectID string
	LimitVal  int64
}

type FetchSubscriptionsForBroadcastRow struct {
	ID                            string
	Type                          string
	ProjectID                     string
	EndpointID                    pgtype.Text
	Function                      pgtype.Text
	FilterConfigEventTypes        []string
	FilterConfigFilterHeaders     []byte
	FilterConfigFilterBody        []byte
	FilterConfigFilterIsFlattened pgtype.Bool
}

// ============================================================================
// BROADCAST & SYNC Operations
// ============================================================================
// Fetch subscriptions matching event type with pagination
func (q *Queries) FetchSubscriptionsForBroadcast(ctx context.Context, arg FetchSubscriptionsForBroadcastParams) ([]FetchSubscriptionsForBroadcastRow, error) {
	rows, err := q.db.Query(ctx, fetchSubscriptionsForBroadcast,
		arg.EventType,
		arg.Cursor,
		arg.ProjectID,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchSubscriptionsForBroadcastRow
	for rows.Next() {
		var i FetchSubscriptionsForBroadcastRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.ProjectID,
			&i.EndpointID,
			&i.Function,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.FilterConfigFilterIsFlattened,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSubscriptionsPaginated = `-- name: FetchSubscriptionsPaginated :many

WITH filtered_subscriptions AS (
    SELECT
        s.id,
        s.name,
        s.type,
        s.project_id,
        s.created_at,
        s.updated_at,
        s.function,
        s.delivery_mode,
        COALESCE(s.endpoint_id, '') AS endpoint_id,
        COALESCE(s.device_id, '') AS device_id,
        COALESCE(s.source_id, '') AS source_id,
        s.alert_config_count,
        s.alert_config_threshold,
        s.retry_config_type,
        s.retry_config_duration,
        s.retry_config_retry_count,
        s.filter_config_event_types,
        s.filter_config_filter_raw_headers,
        s.filter_config_filter_raw_body,
        s.filter_config_filter_is_flattened,
        s.filter_config_filter_headers,
        s.filter_config_filter_body,
        s.rate_limit_config_count,
        s.rate_limit_config_duration,
        COALESCE(em.id, '') AS endpoint_metadata_id,
        COALESCE(em.name, '') AS endpoint_metadata_name,
        COALESCE(em.project_id, '') AS endpoint_metadata_project_id,
        COALESCE(em.support_email, '') AS endpoint_metadata_support_email,
        COALESCE(em.url, '') AS endpoint_metadata_url,
        COALESCE(em.status, '') AS endpoint_metadata_status,
        COALESCE(em.owner_id, '') AS endpoint_metadata_owner_id,
        COALESCE(em.secrets, '[]'::jsonb) AS endpoint_metadata_secrets,
        COALESCE(d.id, '') AS device_metadata_id,
        COALESCE(d.status, '') AS device_metadata_status,
        COALESCE(d.host_name, '') AS device_metadata_host_name,
        COALESCE(sm.id, '') AS source_metadata_id,
        COALESCE(sm.name, '') AS source_metadata_name,
        COALESCE(sm.type, '') AS source_metadata_type,
        COALESCE(sm.mask_id, '') AS source_metadata_mask_id,
        COALESCE(sm.project_id, '') AS source_metadata_project_id,
        COALESCE(sm.is_disabled, FALSE) AS source_metadata_is_disabled,
        COALESCE(sv.type, '') AS source_verifier_type,
        COALESCE(sv.basic_username, '') AS source_verifier_basic_username,
        COALESCE(sv.basic_password, '') AS source_verifier_basic_password,
        COALESCE(sv.api_key_header_name, '') AS source_verifier_api_key_header_name,
        COALESCE(sv.api_key_header_value, '') AS source_verifier_api_key_header_value,
        COALESCE(sv.hmac_hash, '') AS source_verifier_hmac_hash,
        COALESCE(sv.hmac_header, '') AS source_verifier_hmac_header,
        COALESCE(sv.hmac_secret, '') AS source_verifier_hmac_secret,
        COALESCE(sv.hmac_encoding, '') AS source_verifier_hmac_encoding
    FROM convoy.subscriptions s
    LEFT JOIN convoy.endpoints em ON s.endpoint_id = em.id
    LEFT JOIN convoy.sources sm ON s.source_id = sm.id
    LEFT JOIN convoy.source_verifiers sv ON sv.id = sm.source_verifier_id
    LEFT JOIN convoy.devices d ON s.device_id = d.id
    WHERE s.deleted_at IS NULL
        AND s.project_id = $2
        -- Cursor comparison: <= for forward (next), >= for backward (prev)
        AND (
            CASE
                WHEN $1::text = 'next' THEN s.id <= $3
                WHEN $1::text = 'prev' THEN s.id >= $3
                ELSE true
            END
        )
        -- Optional endpoint filter
        AND (
            CASE
                WHEN $4::boolean THEN s.endpoint_id = ANY($5::text[])
                ELSE true
            END
        )
        -- Optional name search filter
        AND (
            CASE
                WHEN $6::boolean THEN s.name ILIKE $7
                ELSE true
            END
        )
    GROUP BY s.id, em.id, sm.id, sv.id, d.id
    -- Sort order: DESC for forward, ASC for backward (will be reversed in outer query for backward)
    ORDER BY
        CASE
            WHEN $1::text = 'next' THEN s.id
        END DESC,
        CASE
            WHEN $1::text = 'prev' THEN s.id
        END ASC
    LIMIT $8
)
SELECT id, name, type, project_id, created_at, updated_at, function, delivery_mode, endpoint_id, device_id, source_id, alert_config_count, alert_config_threshold, retry_config_type, retry_config_duration, retry_config_retry_count, filter_config_event_types, filter_config_filter_raw_headers, filter_config_filter_raw_body, filter_config_filter_is_flattened, filter_config_filter_headers, filter_config_filter_body, rate_limit_config_count, rate_limit_config_duration, endpoint_metadata_id, endpoint_metadata_name, endpoint_metadata_project_id, endpoint_metadata_support_email, endpoint_metadata_url, endpoint_metadata_status, endpoint_metadata_owner_id, endpoint_metadata_secrets, device_metadata_id, device_metadata_status, device_metadata_host_name, source_metadata_id, source_metadata_name, source_metadata_type, source_metadata_mask_id, source_metadata_project_id, source_metadata_is_disabled, source_verifier_type, source_verifier_basic_username, source_verifier_basic_password, source_verifier_api_key_header_name, source_verifier_api_key_header_value, source_verifier_hmac_hash, source_verifier_hmac_header, source_verifier_hmac_secret, source_verifier_hmac_encoding FROM filtered_subscriptions
ORDER BY
    CASE
        WHEN $1::text = 'prev' THEN id
    END DESC,
    CASE
        WHEN $1::text = 'next' THEN id
    END DESC
`

type FetchSubscriptionsPaginatedParams struct {
	Direction         string
	ProjectID         string
	Cursor            string
	HasEndpointFilter bool
	EndpointIds       []string
	HasNameFilter     bool
	NameFilter        string
	LimitVal          int64
}

type FetchSubscriptionsPaginatedRow struct {
	ID                              string
	Name                            string
	Type                            string
	ProjectID                       string
	CreatedAt                       pgtype.Timestamptz
	UpdatedAt                       pgtype.Timestamptz
	Function                        pgtype.Text
	DeliveryMode                    NullConvoyDeliveryMode
	EndpointID                      string
	DeviceID                        string
	SourceID                        string
	AlertConfigCount                int32
	AlertConfigThreshold            string
	RetryConfigType                 string
	RetryConfigDuration             int32
	RetryConfigRetryCount           int32
	FilterConfigEventTypes          []string
	FilterConfigFilterRawHeaders    []byte
	FilterConfigFilterRawBody       []byte
	FilterConfigFilterIsFlattened   pgtype.Bool
	FilterConfigFilterHeaders       []byte
	FilterConfigFilterBody          []byte
	RateLimitConfigCount            int32
	RateLimitConfigDuration         int32
	EndpointMetadataID              string
	EndpointMetadataName            string
	EndpointMetadataProjectID       string
	EndpointMetadataSupportEmail    string
	EndpointMetadataUrl             string
	EndpointMetadataStatus          string
	EndpointMetadataOwnerID         string
	EndpointMetadataSecrets         []byte
	DeviceMetadataID                string
	DeviceMetadataStatus            string
	DeviceMetadataHostName          string
	SourceMetadataID                string
	SourceMetadataName              string
	SourceMetadataType              string
	SourceMetadataMaskID            string
	SourceMetadataProjectID         string
	SourceMetadataIsDisabled        bool
	SourceVerifierType              string
	SourceVerifierBasicUsername     string
	SourceVerifierBasicPassword     string
	SourceVerifierApiKeyHeaderName  string
	SourceVerifierApiKeyHeaderValue string
	SourceVerifierHmacHash          string
	SourceVerifierHmacHeader        string
	SourceVerifierHmacSecret        string
	SourceVerifierHmacEncoding      string
}

// ============================================================================
// PAGINATED Operations
// ============================================================================
// @direction: 'next' for forward pagination, 'prev' for backward pagination
// @has_endpoint_filter: true to filter by endpoint_ids, false to skip
// @has_name_filter: true to filter by name, false to skip
// Final select: reverse order for backward pagination to get DESC order
func (q *Queries) FetchSubscriptionsPaginated(ctx context.Context, arg FetchSubscriptionsPaginatedParams) ([]FetchSubscriptionsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchSubscriptionsPaginated,
		arg.Direction,
		arg.ProjectID,
		arg.Cursor,
		arg.HasEndpointFilter,
		arg.EndpointIds,
		arg.HasNameFilter,
		arg.NameFilter,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchSubscriptionsPaginatedRow
	for rows.Next() {
		var i FetchSubscriptionsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Function,
			&i.DeliveryMode,
			&i.EndpointID,
			&i.DeviceID,
			&i.SourceID,
			&i.AlertConfigCount,
			&i.AlertConfigThreshold,
			&i.RetryConfigType,
			&i.RetryConfigDuration,
			&i.RetryConfigRetryCount,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterRawHeaders,
			&i.FilterConfigFilterRawBody,
			&i.FilterConfigFilterIsFlattened,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.RateLimitConfigCount,
			&i.RateLimitConfigDuration,
			&i.EndpointMetadataID,
			&i.EndpointMetadataName,
			&i.EndpointMetadataProjectID,
			&i.EndpointMetadataSupportEmail,
			&i.EndpointMetadataUrl,
			&i.EndpointMetadataStatus,
			&i.EndpointMetadataOwnerID,
			&i.EndpointMetadataSecrets,
			&i.DeviceMetadataID,
			&i.DeviceMetadataStatus,
			&i.DeviceMetadataHostName,
			&i.SourceMetadataID,
			&i.SourceMetadataName,
			&i.SourceMetadataType,
			&i.SourceMetadataMaskID,
			&i.SourceMetadataProjectID,
			&i.SourceMetadataIsDisabled,
			&i.SourceVerifierType,
			&i.SourceVerifierBasicUsername,
			&i.SourceVerifierBasicPassword,
			&i.SourceVerifierApiKeyHeaderName,
			&i.SourceVerifierApiKeyHeaderValue,
			&i.SourceVerifierHmacHash,
			&i.SourceVerifierHmacHeader,
			&i.SourceVerifierHmacSecret,
			&i.SourceVerifierHmacEncoding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUpdatedSubscriptions = `-- name: FetchUpdatedSubscriptions :many
WITH input_map(id, last_updated_at) AS (
    VALUES ($2, $3::timestamptz)
),
updated_existing AS (
    SELECT
        s.name,
        s.id,
        s.type,
        s.project_id,
        s.endpoint_id,
        s.function,
        s.updated_at,
        s.filter_config_event_types,
        s.filter_config_filter_headers,
        s.filter_config_filter_body,
        s.filter_config_filter_is_flattened,
        s.filter_config_filter_raw_headers,
        s.filter_config_filter_raw_body
    FROM convoy.subscriptions s
    JOIN input_map m ON s.id = m.id
    WHERE s.updated_at > m.last_updated_at
        AND s.project_id = ANY($4::text[])
        AND s.deleted_at IS NULL
),
new_subscriptions AS (
    SELECT
        s.name,
        s.id,
        s.type,
        s.project_id,
        s.endpoint_id,
        s.function,
        s.updated_at,
        s.filter_config_event_types,
        s.filter_config_filter_headers,
        s.filter_config_filter_body,
        s.filter_config_filter_is_flattened,
        s.filter_config_filter_raw_headers,
        s.filter_config_filter_raw_body
    FROM convoy.subscriptions s
    WHERE s.id NOT IN (SELECT id FROM input_map)
        AND s.project_id = ANY($4::text[])
        AND s.deleted_at IS NULL
)
SELECT name, id, type, project_id, endpoint_id, function, updated_at, filter_config_event_types, filter_config_filter_headers, filter_config_filter_body, filter_config_filter_is_flattened, filter_config_filter_raw_headers, filter_config_filter_raw_body FROM updated_existing
UNION ALL
SELECT name, id, type, project_id, endpoint_id, function, updated_at, filter_config_event_types, filter_config_filter_headers, filter_config_filter_body, filter_config_filter_is_flattened, filter_config_filter_raw_headers, filter_config_filter_raw_body FROM new_subscriptions
ORDER BY id
LIMIT $1
`

type FetchUpdatedSubscriptionsParams struct {
	LimitVal        int64
	SubscriptionID1 pgtype.Text
	UpdatedAt1      pgtype.Timestamptz
	ProjectIds      []string
}

type FetchUpdatedSubscriptionsRow struct {
	Name                          string
	ID                            string
	Type                          string
	ProjectID                     string
	EndpointID                    pgtype.Text
	Function                      pgtype.Text
	UpdatedAt                     pgtype.Timestamptz
	FilterConfigEventTypes        []string
	FilterConfigFilterHeaders     []byte
	FilterConfigFilterBody        []byte
	FilterConfigFilterIsFlattened pgtype.Bool
	FilterConfigFilterRawHeaders  []byte
	FilterConfigFilterRawBody     []byte
}

// Fetch subscriptions that have been updated since last sync
// Uses VALUES clause for input map (id, last_updated_at pairs)
// @values_clause will be substituted with the actual VALUES
func (q *Queries) FetchUpdatedSubscriptions(ctx context.Context, arg FetchUpdatedSubscriptionsParams) ([]FetchUpdatedSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, fetchUpdatedSubscriptions,
		arg.LimitVal,
		arg.SubscriptionID1,
		arg.UpdatedAt1,
		arg.ProjectIds,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchUpdatedSubscriptionsRow
	for rows.Next() {
		var i FetchUpdatedSubscriptionsRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.Type,
			&i.ProjectID,
			&i.EndpointID,
			&i.Function,
			&i.UpdatedAt,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.FilterConfigFilterIsFlattened,
			&i.FilterConfigFilterRawHeaders,
			&i.FilterConfigFilterRawBody,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertSubscriptionEventTypeFilters = `-- name: InsertSubscriptionEventTypeFilters :exec
INSERT INTO convoy.filters (
    id,
    subscription_id,
    event_type,
    headers,
    body,
    raw_headers,
    raw_body
)
SELECT
    convoy.generate_ulid()::VARCHAR,
    id,
    unnest(filter_config_event_types),
    filter_config_filter_headers,
    filter_config_filter_body,
    filter_config_filter_raw_headers,
    filter_config_filter_raw_body
FROM convoy.subscriptions
WHERE id = $1 AND deleted_at IS NULL
ON CONFLICT DO NOTHING
`

func (q *Queries) InsertSubscriptionEventTypeFilters(ctx context.Context, subscriptionID pgtype.Text) error {
	_, err := q.db.Exec(ctx, insertSubscriptionEventTypeFilters, subscriptionID)
	return err
}

const loadAllSubscriptionsConfiguration = `-- name: LoadAllSubscriptionsConfiguration :many
SELECT
    name,
    id,
    type,
    project_id,
    endpoint_id,
    function,
    updated_at,
    filter_config_event_types,
    filter_config_filter_headers,
    filter_config_filter_body,
    filter_config_filter_is_flattened
FROM convoy.subscriptions
WHERE id > $1
    AND project_id = ANY($2::text[])
    AND deleted_at IS NULL
ORDER BY id
LIMIT $3
`

type LoadAllSubscriptionsConfigurationParams struct {
	Cursor     string
	ProjectIds []string
	LimitVal   int64
}

type LoadAllSubscriptionsConfigurationRow struct {
	Name                          string
	ID                            string
	Type                          string
	ProjectID                     string
	EndpointID                    pgtype.Text
	Function                      pgtype.Text
	UpdatedAt                     pgtype.Timestamptz
	FilterConfigEventTypes        []string
	FilterConfigFilterHeaders     []byte
	FilterConfigFilterBody        []byte
	FilterConfigFilterIsFlattened pgtype.Bool
}

// Load all subscription configs for multiple projects with pagination
func (q *Queries) LoadAllSubscriptionsConfiguration(ctx context.Context, arg LoadAllSubscriptionsConfigurationParams) ([]LoadAllSubscriptionsConfigurationRow, error) {
	rows, err := q.db.Query(ctx, loadAllSubscriptionsConfiguration, arg.Cursor, arg.ProjectIds, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadAllSubscriptionsConfigurationRow
	for rows.Next() {
		var i LoadAllSubscriptionsConfigurationRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.Type,
			&i.ProjectID,
			&i.EndpointID,
			&i.Function,
			&i.UpdatedAt,
			&i.FilterConfigEventTypes,
			&i.FilterConfigFilterHeaders,
			&i.FilterConfigFilterBody,
			&i.FilterConfigFilterIsFlattened,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscription = `-- name: UpdateSubscription :execresult

UPDATE convoy.subscriptions
SET
    name = $1,
    endpoint_id = $2,
    source_id = $3,
    alert_config_count = $4,
    alert_config_threshold = $5,
    retry_config_type = $6,
    retry_config_duration = $7,
    retry_config_retry_count = $8,
    filter_config_event_types = $9,
    filter_config_filter_headers = $10,
    filter_config_filter_body = $11,
    filter_config_filter_is_flattened = $12,
    filter_config_filter_raw_headers = $13,
    filter_config_filter_raw_body = $14,
    rate_limit_config_count = $15,
    rate_limit_config_duration = $16,
    function = $17,
    delivery_mode = CASE
        WHEN $18 = '' OR $18 IS NULL THEN 'at_least_once'::convoy.delivery_mode
        ELSE $18::convoy.delivery_mode
    END,
    updated_at = NOW()
WHERE id = $19 AND project_id = $20 AND deleted_at IS NULL
`

type UpdateSubscriptionParams struct {
	Name                          string
	EndpointID                    pgtype.Text
	SourceID                      pgtype.Text
	AlertConfigCount              int32
	AlertConfigThreshold          string
	RetryConfigType               string
	RetryConfigDuration           int32
	RetryConfigRetryCount         int32
	FilterConfigEventTypes        []string
	FilterConfigFilterHeaders     []byte
	FilterConfigFilterBody        []byte
	FilterConfigFilterIsFlattened pgtype.Bool
	FilterConfigFilterRawHeaders  []byte
	FilterConfigFilterRawBody     []byte
	RateLimitConfigCount          int32
	RateLimitConfigDuration       int32
	Function                      pgtype.Text
	DeliveryMode                  pgtype.Text
	ID                            string
	ProjectID                     string
}

// ============================================================================
// UPDATE Operations
// ============================================================================
func (q *Queries) UpdateSubscription(ctx context.Context, arg UpdateSubscriptionParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateSubscription,
		arg.Name,
		arg.EndpointID,
		arg.SourceID,
		arg.AlertConfigCount,
		arg.AlertConfigThreshold,
		arg.RetryConfigType,
		arg.RetryConfigDuration,
		arg.RetryConfigRetryCount,
		arg.FilterConfigEventTypes,
		arg.FilterConfigFilterHeaders,
		arg.FilterConfigFilterBody,
		arg.FilterConfigFilterIsFlattened,
		arg.FilterConfigFilterRawHeaders,
		arg.FilterConfigFilterRawBody,
		arg.RateLimitConfigCount,
		arg.RateLimitConfigDuration,
		arg.Function,
		arg.DeliveryMode,
		arg.ID,
		arg.ProjectID,
	)
}

const upsertSubscriptionEventTypes = `-- name: UpsertSubscriptionEventTypes :exec
INSERT INTO convoy.event_types (id, name, project_id, description, category)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT DO NOTHING
`

type UpsertSubscriptionEventTypesParams struct {
	ID          string
	Name        string
	ProjectID   string
	Description pgtype.Text
	Category    pgtype.Text
}

func (q *Queries) UpsertSubscriptionEventTypes(ctx context.Context, arg UpsertSubscriptionEventTypesParams) error {
	_, err := q.db.Exec(ctx, upsertSubscriptionEventTypes,
		arg.ID,
		arg.Name,
		arg.ProjectID,
		arg.Description,
		arg.Category,
	)
	return err
}
