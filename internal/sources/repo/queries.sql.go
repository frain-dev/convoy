// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const countPrevSources = `-- name: CountPrevSources :one
SELECT COUNT(DISTINCT s.id) AS count
FROM convoy.sources s
WHERE s.deleted_at IS NULL
    AND s.project_id = $1
    AND s.id > $2
    -- Optional type filter
    AND (
        CASE
            WHEN $3::boolean THEN s.type = $4
            ELSE true
        END
    )
    -- Optional provider filter
    AND (
        CASE
            WHEN $5::boolean THEN s.provider = $6
            ELSE true
        END
    )
    -- Optional name search filter
    AND (
        CASE
            WHEN $7::boolean THEN s.name ILIKE $8
            ELSE true
        END
    )
GROUP BY s.id
ORDER BY s.id DESC
LIMIT 1
`

type CountPrevSourcesParams struct {
	ProjectID         string
	Cursor            string
	HasTypeFilter     bool
	TypeFilter        string
	HasProviderFilter bool
	ProviderFilter    string
	HasQueryFilter    bool
	QueryFilter       string
}

// Unified count query for pagination prev row count
func (q *Queries) CountPrevSources(ctx context.Context, arg CountPrevSourcesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPrevSources,
		arg.ProjectID,
		arg.Cursor,
		arg.HasTypeFilter,
		arg.TypeFilter,
		arg.HasProviderFilter,
		arg.ProviderFilter,
		arg.HasQueryFilter,
		arg.QueryFilter,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSource = `-- name: CreateSource :exec
INSERT INTO convoy.sources (
    id,
    source_verifier_id,
    name,
    type,
    mask_id,
    provider,
    is_disabled,
    forward_headers,
    project_id,
    pub_sub,
    custom_response_body,
    custom_response_content_type,
    idempotency_keys,
    body_function,
    header_function
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13,
    $14,
    $15
)
`

type CreateSourceParams struct {
	ID                        string
	SourceVerifierID          pgtype.Text
	Name                      string
	Type                      string
	MaskID                    string
	Provider                  string
	IsDisabled                bool
	ForwardHeaders            []string
	ProjectID                 string
	PubSub                    []byte
	CustomResponseBody        pgtype.Text
	CustomResponseContentType pgtype.Text
	IdempotencyKeys           []string
	BodyFunction              pgtype.Text
	HeaderFunction            pgtype.Text
}

func (q *Queries) CreateSource(ctx context.Context, arg CreateSourceParams) error {
	_, err := q.db.Exec(ctx, createSource,
		arg.ID,
		arg.SourceVerifierID,
		arg.Name,
		arg.Type,
		arg.MaskID,
		arg.Provider,
		arg.IsDisabled,
		arg.ForwardHeaders,
		arg.ProjectID,
		arg.PubSub,
		arg.CustomResponseBody,
		arg.CustomResponseContentType,
		arg.IdempotencyKeys,
		arg.BodyFunction,
		arg.HeaderFunction,
	)
	return err
}

const createSourceVerifier = `-- name: CreateSourceVerifier :exec


INSERT INTO convoy.source_verifiers (
    id,
    type,
    basic_username,
    basic_password,
    api_key_header_name,
    api_key_header_value,
    hmac_hash,
    hmac_header,
    hmac_secret,
    hmac_encoding
)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
`

type CreateSourceVerifierParams struct {
	ID                string
	Type              string
	BasicUsername     pgtype.Text
	BasicPassword     pgtype.Text
	ApiKeyHeaderName  pgtype.Text
	ApiKeyHeaderValue pgtype.Text
	HmacHash          pgtype.Text
	HmacHeader        pgtype.Text
	HmacSecret        pgtype.Text
	HmacEncoding      pgtype.Text
}

// Sources Queries
// ============================================================================
// CREATE Operations
// ============================================================================
func (q *Queries) CreateSourceVerifier(ctx context.Context, arg CreateSourceVerifierParams) error {
	_, err := q.db.Exec(ctx, createSourceVerifier,
		arg.ID,
		arg.Type,
		arg.BasicUsername,
		arg.BasicPassword,
		arg.ApiKeyHeaderName,
		arg.ApiKeyHeaderValue,
		arg.HmacHash,
		arg.HmacHeader,
		arg.HmacSecret,
		arg.HmacEncoding,
	)
	return err
}

const deleteSource = `-- name: DeleteSource :execresult

UPDATE convoy.sources
SET deleted_at = NOW()
WHERE id = $1 AND project_id = $2 AND deleted_at IS NULL
`

type DeleteSourceParams struct {
	ID        string
	ProjectID string
}

// ============================================================================
// DELETE Operations
// ============================================================================
func (q *Queries) DeleteSource(ctx context.Context, arg DeleteSourceParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteSource, arg.ID, arg.ProjectID)
}

const deleteSourceSubscriptions = `-- name: DeleteSourceSubscriptions :exec
UPDATE convoy.subscriptions
SET deleted_at = NOW()
WHERE source_id = $1 AND project_id = $2 AND deleted_at IS NULL
`

type DeleteSourceSubscriptionsParams struct {
	SourceID  pgtype.Text
	ProjectID string
}

func (q *Queries) DeleteSourceSubscriptions(ctx context.Context, arg DeleteSourceSubscriptionsParams) error {
	_, err := q.db.Exec(ctx, deleteSourceSubscriptions, arg.SourceID, arg.ProjectID)
	return err
}

const deleteSourceVerifier = `-- name: DeleteSourceVerifier :exec
UPDATE convoy.source_verifiers
SET deleted_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteSourceVerifier(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSourceVerifier, id)
	return err
}

const fetchPubSubSourcesByProjectIDs = `-- name: FetchPubSubSourcesByProjectIDs :many
SELECT
    s.id,
    s.name,
    s.type,
    s.pub_sub,
    s.mask_id,
    s.provider,
    s.is_disabled,
    s.forward_headers,
    s.idempotency_keys,
    s.body_function,
    s.header_function,
    s.project_id,
    s.created_at,
    s.updated_at
FROM convoy.sources s
WHERE s.type = $1
    AND s.project_id = ANY($2::text[])
    AND s.deleted_at IS NULL
    AND (s.id <= $3 OR $3 = '')
ORDER BY s.id DESC
LIMIT $4
`

type FetchPubSubSourcesByProjectIDsParams struct {
	SourceType string
	ProjectIds []string
	Cursor     string
	LimitVal   int64
}

type FetchPubSubSourcesByProjectIDsRow struct {
	ID              string
	Name            string
	Type            string
	PubSub          []byte
	MaskID          string
	Provider        string
	IsDisabled      bool
	ForwardHeaders  []string
	IdempotencyKeys []string
	BodyFunction    pgtype.Text
	HeaderFunction  pgtype.Text
	ProjectID       string
	CreatedAt       pgtype.Timestamptz
	UpdatedAt       pgtype.Timestamptz
}

// Fetch PubSub-type sources across multiple projects with pagination
func (q *Queries) FetchPubSubSourcesByProjectIDs(ctx context.Context, arg FetchPubSubSourcesByProjectIDsParams) ([]FetchPubSubSourcesByProjectIDsRow, error) {
	rows, err := q.db.Query(ctx, fetchPubSubSourcesByProjectIDs,
		arg.SourceType,
		arg.ProjectIds,
		arg.Cursor,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchPubSubSourcesByProjectIDsRow
	for rows.Next() {
		var i FetchPubSubSourcesByProjectIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.PubSub,
			&i.MaskID,
			&i.Provider,
			&i.IsDisabled,
			&i.ForwardHeaders,
			&i.IdempotencyKeys,
			&i.BodyFunction,
			&i.HeaderFunction,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSourceByID = `-- name: FetchSourceByID :one

SELECT
    s.id,
    s.name,
    s.type,
    s.pub_sub,
    s.mask_id,
    s.provider,
    s.is_disabled,
    s.forward_headers,
    s.idempotency_keys,
    s.project_id,
    s.body_function,
    s.header_function,
    COALESCE(s.source_verifier_id, '') AS source_verifier_id,
    COALESCE(s.custom_response_body, '') AS custom_response_body,
    COALESCE(s.custom_response_content_type, '') AS custom_response_content_type,
    COALESCE(sv.type, '') AS verifier_type,
    COALESCE(sv.basic_username, '') AS verifier_basic_username,
    COALESCE(sv.basic_password, '') AS verifier_basic_password,
    COALESCE(sv.api_key_header_name, '') AS verifier_api_key_header_name,
    COALESCE(sv.api_key_header_value, '') AS verifier_api_key_header_value,
    COALESCE(sv.hmac_hash, '') AS verifier_hmac_hash,
    COALESCE(sv.hmac_header, '') AS verifier_hmac_header,
    COALESCE(sv.hmac_secret, '') AS verifier_hmac_secret,
    COALESCE(sv.hmac_encoding, '') AS verifier_hmac_encoding,
    s.created_at,
    s.updated_at
FROM convoy.sources AS s
LEFT JOIN convoy.source_verifiers sv ON s.source_verifier_id = sv.id
WHERE s.id = $1 AND s.deleted_at IS NULL
`

type FetchSourceByIDRow struct {
	ID                        string
	Name                      string
	Type                      string
	PubSub                    []byte
	MaskID                    string
	Provider                  string
	IsDisabled                bool
	ForwardHeaders            []string
	IdempotencyKeys           []string
	ProjectID                 string
	BodyFunction              pgtype.Text
	HeaderFunction            pgtype.Text
	SourceVerifierID          string
	CustomResponseBody        string
	CustomResponseContentType string
	VerifierType              string
	VerifierBasicUsername     string
	VerifierBasicPassword     string
	VerifierApiKeyHeaderName  string
	VerifierApiKeyHeaderValue string
	VerifierHmacHash          string
	VerifierHmacHeader        string
	VerifierHmacSecret        string
	VerifierHmacEncoding      string
	CreatedAt                 pgtype.Timestamptz
	UpdatedAt                 pgtype.Timestamptz
}

// ============================================================================
// FETCH Operations
// ============================================================================
func (q *Queries) FetchSourceByID(ctx context.Context, id string) (FetchSourceByIDRow, error) {
	row := q.db.QueryRow(ctx, fetchSourceByID, id)
	var i FetchSourceByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.PubSub,
		&i.MaskID,
		&i.Provider,
		&i.IsDisabled,
		&i.ForwardHeaders,
		&i.IdempotencyKeys,
		&i.ProjectID,
		&i.BodyFunction,
		&i.HeaderFunction,
		&i.SourceVerifierID,
		&i.CustomResponseBody,
		&i.CustomResponseContentType,
		&i.VerifierType,
		&i.VerifierBasicUsername,
		&i.VerifierBasicPassword,
		&i.VerifierApiKeyHeaderName,
		&i.VerifierApiKeyHeaderValue,
		&i.VerifierHmacHash,
		&i.VerifierHmacHeader,
		&i.VerifierHmacSecret,
		&i.VerifierHmacEncoding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchSourceByMaskID = `-- name: FetchSourceByMaskID :one
SELECT
    s.id,
    s.name,
    s.type,
    s.pub_sub,
    s.mask_id,
    s.provider,
    s.is_disabled,
    s.forward_headers,
    s.idempotency_keys,
    s.project_id,
    s.body_function,
    s.header_function,
    COALESCE(s.source_verifier_id, '') AS source_verifier_id,
    COALESCE(s.custom_response_body, '') AS custom_response_body,
    COALESCE(s.custom_response_content_type, '') AS custom_response_content_type,
    COALESCE(sv.type, '') AS verifier_type,
    COALESCE(sv.basic_username, '') AS verifier_basic_username,
    COALESCE(sv.basic_password, '') AS verifier_basic_password,
    COALESCE(sv.api_key_header_name, '') AS verifier_api_key_header_name,
    COALESCE(sv.api_key_header_value, '') AS verifier_api_key_header_value,
    COALESCE(sv.hmac_hash, '') AS verifier_hmac_hash,
    COALESCE(sv.hmac_header, '') AS verifier_hmac_header,
    COALESCE(sv.hmac_secret, '') AS verifier_hmac_secret,
    COALESCE(sv.hmac_encoding, '') AS verifier_hmac_encoding,
    s.created_at,
    s.updated_at
FROM convoy.sources AS s
LEFT JOIN convoy.source_verifiers sv ON s.source_verifier_id = sv.id
WHERE s.mask_id = $1 AND s.deleted_at IS NULL
`

type FetchSourceByMaskIDRow struct {
	ID                        string
	Name                      string
	Type                      string
	PubSub                    []byte
	MaskID                    string
	Provider                  string
	IsDisabled                bool
	ForwardHeaders            []string
	IdempotencyKeys           []string
	ProjectID                 string
	BodyFunction              pgtype.Text
	HeaderFunction            pgtype.Text
	SourceVerifierID          string
	CustomResponseBody        string
	CustomResponseContentType string
	VerifierType              string
	VerifierBasicUsername     string
	VerifierBasicPassword     string
	VerifierApiKeyHeaderName  string
	VerifierApiKeyHeaderValue string
	VerifierHmacHash          string
	VerifierHmacHeader        string
	VerifierHmacSecret        string
	VerifierHmacEncoding      string
	CreatedAt                 pgtype.Timestamptz
	UpdatedAt                 pgtype.Timestamptz
}

func (q *Queries) FetchSourceByMaskID(ctx context.Context, maskID string) (FetchSourceByMaskIDRow, error) {
	row := q.db.QueryRow(ctx, fetchSourceByMaskID, maskID)
	var i FetchSourceByMaskIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.PubSub,
		&i.MaskID,
		&i.Provider,
		&i.IsDisabled,
		&i.ForwardHeaders,
		&i.IdempotencyKeys,
		&i.ProjectID,
		&i.BodyFunction,
		&i.HeaderFunction,
		&i.SourceVerifierID,
		&i.CustomResponseBody,
		&i.CustomResponseContentType,
		&i.VerifierType,
		&i.VerifierBasicUsername,
		&i.VerifierBasicPassword,
		&i.VerifierApiKeyHeaderName,
		&i.VerifierApiKeyHeaderValue,
		&i.VerifierHmacHash,
		&i.VerifierHmacHeader,
		&i.VerifierHmacSecret,
		&i.VerifierHmacEncoding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchSourceByName = `-- name: FetchSourceByName :one
SELECT
    s.id,
    s.name,
    s.type,
    s.pub_sub,
    s.mask_id,
    s.provider,
    s.is_disabled,
    s.forward_headers,
    s.idempotency_keys,
    s.project_id,
    s.body_function,
    s.header_function,
    COALESCE(s.source_verifier_id, '') AS source_verifier_id,
    COALESCE(s.custom_response_body, '') AS custom_response_body,
    COALESCE(s.custom_response_content_type, '') AS custom_response_content_type,
    COALESCE(sv.type, '') AS verifier_type,
    COALESCE(sv.basic_username, '') AS verifier_basic_username,
    COALESCE(sv.basic_password, '') AS verifier_basic_password,
    COALESCE(sv.api_key_header_name, '') AS verifier_api_key_header_name,
    COALESCE(sv.api_key_header_value, '') AS verifier_api_key_header_value,
    COALESCE(sv.hmac_hash, '') AS verifier_hmac_hash,
    COALESCE(sv.hmac_header, '') AS verifier_hmac_header,
    COALESCE(sv.hmac_secret, '') AS verifier_hmac_secret,
    COALESCE(sv.hmac_encoding, '') AS verifier_hmac_encoding,
    s.created_at,
    s.updated_at
FROM convoy.sources AS s
LEFT JOIN convoy.source_verifiers sv ON s.source_verifier_id = sv.id
WHERE s.project_id = $1 AND s.name = $2 AND s.deleted_at IS NULL
`

type FetchSourceByNameParams struct {
	ProjectID string
	Name      string
}

type FetchSourceByNameRow struct {
	ID                        string
	Name                      string
	Type                      string
	PubSub                    []byte
	MaskID                    string
	Provider                  string
	IsDisabled                bool
	ForwardHeaders            []string
	IdempotencyKeys           []string
	ProjectID                 string
	BodyFunction              pgtype.Text
	HeaderFunction            pgtype.Text
	SourceVerifierID          string
	CustomResponseBody        string
	CustomResponseContentType string
	VerifierType              string
	VerifierBasicUsername     string
	VerifierBasicPassword     string
	VerifierApiKeyHeaderName  string
	VerifierApiKeyHeaderValue string
	VerifierHmacHash          string
	VerifierHmacHeader        string
	VerifierHmacSecret        string
	VerifierHmacEncoding      string
	CreatedAt                 pgtype.Timestamptz
	UpdatedAt                 pgtype.Timestamptz
}

func (q *Queries) FetchSourceByName(ctx context.Context, arg FetchSourceByNameParams) (FetchSourceByNameRow, error) {
	row := q.db.QueryRow(ctx, fetchSourceByName, arg.ProjectID, arg.Name)
	var i FetchSourceByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.PubSub,
		&i.MaskID,
		&i.Provider,
		&i.IsDisabled,
		&i.ForwardHeaders,
		&i.IdempotencyKeys,
		&i.ProjectID,
		&i.BodyFunction,
		&i.HeaderFunction,
		&i.SourceVerifierID,
		&i.CustomResponseBody,
		&i.CustomResponseContentType,
		&i.VerifierType,
		&i.VerifierBasicUsername,
		&i.VerifierBasicPassword,
		&i.VerifierApiKeyHeaderName,
		&i.VerifierApiKeyHeaderValue,
		&i.VerifierHmacHash,
		&i.VerifierHmacHeader,
		&i.VerifierHmacSecret,
		&i.VerifierHmacEncoding,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const fetchSourcesPaginated = `-- name: FetchSourcesPaginated :many

WITH filtered_sources AS (
    SELECT
        s.id,
        s.name,
        s.type,
        s.pub_sub,
        s.mask_id,
        s.provider,
        s.is_disabled,
        s.forward_headers,
        s.idempotency_keys,
        s.project_id,
        s.body_function,
        s.header_function,
        COALESCE(s.source_verifier_id, '') AS source_verifier_id,
        COALESCE(s.custom_response_body, '') AS custom_response_body,
        COALESCE(s.custom_response_content_type, '') AS custom_response_content_type,
        COALESCE(sv.type, '') AS verifier_type,
        COALESCE(sv.basic_username, '') AS verifier_basic_username,
        COALESCE(sv.basic_password, '') AS verifier_basic_password,
        COALESCE(sv.api_key_header_name, '') AS verifier_api_key_header_name,
        COALESCE(sv.api_key_header_value, '') AS verifier_api_key_header_value,
        COALESCE(sv.hmac_hash, '') AS verifier_hmac_hash,
        COALESCE(sv.hmac_header, '') AS verifier_hmac_header,
        COALESCE(sv.hmac_secret, '') AS verifier_hmac_secret,
        COALESCE(sv.hmac_encoding, '') AS verifier_hmac_encoding,
        s.created_at,
        s.updated_at
    FROM convoy.sources s
    LEFT JOIN convoy.source_verifiers sv ON s.source_verifier_id = sv.id
    WHERE s.deleted_at IS NULL
        AND s.project_id = $2
        -- Cursor comparison: <= for forward (next), >= for backward (prev)
        AND (
            CASE
                WHEN $1::text = 'next' THEN s.id <= $3
                WHEN $1::text = 'prev' THEN s.id >= $3
                ELSE true
            END
        )
        -- Optional type filter
        AND (
            CASE
                WHEN $4::boolean THEN s.type = $5
                ELSE true
            END
        )
        -- Optional provider filter
        AND (
            CASE
                WHEN $6::boolean THEN s.provider = $7
                ELSE true
            END
        )
        -- Optional name search filter
        AND (
            CASE
                WHEN $8::boolean THEN s.name ILIKE $9
                ELSE true
            END
        )
    GROUP BY s.id, sv.id
    -- Sort order: DESC for forward, ASC for backward (will be reversed in outer query for backward)
    ORDER BY
        CASE
            WHEN $1::text = 'next' THEN s.id
        END DESC,
        CASE
            WHEN $1::text = 'prev' THEN s.id
        END ASC
    LIMIT $10
)
SELECT id, name, type, pub_sub, mask_id, provider, is_disabled, forward_headers, idempotency_keys, project_id, body_function, header_function, source_verifier_id, custom_response_body, custom_response_content_type, verifier_type, verifier_basic_username, verifier_basic_password, verifier_api_key_header_name, verifier_api_key_header_value, verifier_hmac_hash, verifier_hmac_header, verifier_hmac_secret, verifier_hmac_encoding, created_at, updated_at FROM filtered_sources
ORDER BY
    CASE
        WHEN $1::text = 'prev' THEN id
    END DESC,
    CASE
        WHEN $1::text = 'next' THEN id
    END DESC
`

type FetchSourcesPaginatedParams struct {
	Direction         string
	ProjectID         string
	Cursor            string
	HasTypeFilter     bool
	TypeFilter        string
	HasProviderFilter bool
	ProviderFilter    string
	HasQueryFilter    bool
	QueryFilter       string
	LimitVal          int64
}

type FetchSourcesPaginatedRow struct {
	ID                        string
	Name                      string
	Type                      string
	PubSub                    []byte
	MaskID                    string
	Provider                  string
	IsDisabled                bool
	ForwardHeaders            []string
	IdempotencyKeys           []string
	ProjectID                 string
	BodyFunction              pgtype.Text
	HeaderFunction            pgtype.Text
	SourceVerifierID          string
	CustomResponseBody        string
	CustomResponseContentType string
	VerifierType              string
	VerifierBasicUsername     string
	VerifierBasicPassword     string
	VerifierApiKeyHeaderName  string
	VerifierApiKeyHeaderValue string
	VerifierHmacHash          string
	VerifierHmacHeader        string
	VerifierHmacSecret        string
	VerifierHmacEncoding      string
	CreatedAt                 pgtype.Timestamptz
	UpdatedAt                 pgtype.Timestamptz
}

// ============================================================================
// PAGINATED LIST Operations
// ============================================================================
// @direction: 'next' for forward pagination, 'prev' for backward pagination
// @has_type_filter: true to filter by type, false to skip
// @has_provider_filter: true to filter by provider, false to skip
// @has_query_filter: true to filter by name search, false to skip
// Final select: reverse order for backward pagination to get DESC order
func (q *Queries) FetchSourcesPaginated(ctx context.Context, arg FetchSourcesPaginatedParams) ([]FetchSourcesPaginatedRow, error) {
	rows, err := q.db.Query(ctx, fetchSourcesPaginated,
		arg.Direction,
		arg.ProjectID,
		arg.Cursor,
		arg.HasTypeFilter,
		arg.TypeFilter,
		arg.HasProviderFilter,
		arg.ProviderFilter,
		arg.HasQueryFilter,
		arg.QueryFilter,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchSourcesPaginatedRow
	for rows.Next() {
		var i FetchSourcesPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.PubSub,
			&i.MaskID,
			&i.Provider,
			&i.IsDisabled,
			&i.ForwardHeaders,
			&i.IdempotencyKeys,
			&i.ProjectID,
			&i.BodyFunction,
			&i.HeaderFunction,
			&i.SourceVerifierID,
			&i.CustomResponseBody,
			&i.CustomResponseContentType,
			&i.VerifierType,
			&i.VerifierBasicUsername,
			&i.VerifierBasicPassword,
			&i.VerifierApiKeyHeaderName,
			&i.VerifierApiKeyHeaderValue,
			&i.VerifierHmacHash,
			&i.VerifierHmacHeader,
			&i.VerifierHmacSecret,
			&i.VerifierHmacEncoding,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSource = `-- name: UpdateSource :execresult
UPDATE convoy.sources
SET
    name = $1,
    type = $2,
    mask_id = $3,
    provider = $4,
    is_disabled = $5,
    forward_headers = $6,
    project_id = $7,
    pub_sub = $8,
    custom_response_body = $9,
    custom_response_content_type = $10,
    idempotency_keys = $11,
    body_function = $12,
    header_function = $13,
    updated_at = NOW()
WHERE id = $14 AND deleted_at IS NULL
`

type UpdateSourceParams struct {
	Name                      string
	Type                      string
	MaskID                    string
	Provider                  string
	IsDisabled                bool
	ForwardHeaders            []string
	ProjectID                 string
	PubSub                    []byte
	CustomResponseBody        pgtype.Text
	CustomResponseContentType pgtype.Text
	IdempotencyKeys           []string
	BodyFunction              pgtype.Text
	HeaderFunction            pgtype.Text
	ID                        string
}

func (q *Queries) UpdateSource(ctx context.Context, arg UpdateSourceParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateSource,
		arg.Name,
		arg.Type,
		arg.MaskID,
		arg.Provider,
		arg.IsDisabled,
		arg.ForwardHeaders,
		arg.ProjectID,
		arg.PubSub,
		arg.CustomResponseBody,
		arg.CustomResponseContentType,
		arg.IdempotencyKeys,
		arg.BodyFunction,
		arg.HeaderFunction,
		arg.ID,
	)
}

const updateSourceVerifier = `-- name: UpdateSourceVerifier :execresult

UPDATE convoy.source_verifiers
SET
    type = $1,
    basic_username = $2,
    basic_password = $3,
    api_key_header_name = $4,
    api_key_header_value = $5,
    hmac_hash = $6,
    hmac_header = $7,
    hmac_secret = $8,
    hmac_encoding = $9,
    updated_at = NOW()
WHERE id = $10 AND deleted_at IS NULL
`

type UpdateSourceVerifierParams struct {
	Type              string
	BasicUsername     pgtype.Text
	BasicPassword     pgtype.Text
	ApiKeyHeaderName  pgtype.Text
	ApiKeyHeaderValue pgtype.Text
	HmacHash          pgtype.Text
	HmacHeader        pgtype.Text
	HmacSecret        pgtype.Text
	HmacEncoding      pgtype.Text
	ID                string
}

// ============================================================================
// UPDATE Operations
// ============================================================================
func (q *Queries) UpdateSourceVerifier(ctx context.Context, arg UpdateSourceVerifierParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateSourceVerifier,
		arg.Type,
		arg.BasicUsername,
		arg.BasicPassword,
		arg.ApiKeyHeaderName,
		arg.ApiKeyHeaderValue,
		arg.HmacHash,
		arg.HmacHeader,
		arg.HmacSecret,
		arg.HmacEncoding,
		arg.ID,
	)
}
